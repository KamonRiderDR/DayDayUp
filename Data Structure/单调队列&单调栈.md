[TOC]

# 单调队列 && 单调栈

## 单调队列

> ***“如果一个选手比你小还比你强，你就可以退役了。”**——单调队列的原理*

**单调队列**是一种主要用于解决**滑动窗口**类问题的数据结构。基本结构是双向队列$deque$，按照单调递减或递增的顺序存放。换言之，就是首尾的两个元素分别对应两个极端值。

当然，作为队列，所有的操作都只是在首尾完成的。

在这搬出百度百科的解释：不断地向缓存数组里读入元素，也不时地去掉最老的元素，不定期的询问当前缓存数组里的最小的元素。

用单调队列来解决问题，一般都是需要得到当前的某个范围内的最小值或最大值。





### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

------

我们以此题为例，研究一下优先队列。由浅入深，先考虑暴力，即每次都从当前下标开始，无疑会做很多没用的事。由于我们只要知道最值就好，因此我们使用单调队列。考虑以下几点：

（1）我们这里假设单调队列是递减的。$q.front() \ge q[i] \ge q.back()$.

（2）每次遇到新的元素就想办法把它插入队列，同时注意==保持性质==：单调+该cache维护在合法的范围内。显然我们要分两步：

​		（2.1）插入队首/队尾。这里我们从尾部插入。

```c++
            while (!q.empty() && nums[i] >= nums[q.back()])	q.pop_back();
            q.push_back(i);
```

​		（2.2）调整队尾/队首。这里我们调整头部。

```c++
            queue.push_back( i );
            while( queue.front() <= i-k )	queue.pop_front();
            res.push_back( nums[queue.front()] );
```

<div align = 'center'><font color = indigo><B>一般默认还是以单调减为准。







## 单调栈

单调栈定义类比单调队列，此处略。



### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

------

比较直观的想法是可以用单调队列去解，从后往前。但是这个不完全准确。注意到一个明显的区别：单调队列中处理的滑动窗口是有定长的，这里长度是不固定的。

我们用单调栈来实现。先上代码：

```c++
        for( int i = 0;i != n;i++ )
        {
            while( !stack.empty() && T[i]>T[stack.top()] )
            {
                int prev = stack.top();
                res[ prev ] = i-prev;
                stack.pop();
            }
            stack.push( i );
        }
        return res;
```

<img src=".\image\Deque_01.png" style="zoom:50%;" />

这里的思维其实是有一点相反的：我们用当前的$index$去更新栈中所有符合要求的$index$。具体来看：

（1）显然栈中所有的元素对应的下标此时都没有更新（其实还没赋值）。

（2）栈顶元素前面的元素还需要看嘛？答案是不需要，因为可以证明，如果一个元素在栈顶前就被弹出去了，说明最优解一定在栈顶以前。



### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) 

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

<img src=".\image\Deque_02.png" style="zoom:67%;" />

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。

------

有一种显然的想法：双指针：每个位置都向右找到合适的右下标。

关于单调栈的用法和解释，官方给出的像奥里给一样。这里做一点自己的说明：

我们对于当前下标，同时向左右延伸，那么我们什么时候停止呢：$\star height[i] > right[i] \&\& height[i]<left[i]$。

那我们就可以顺理成章的引入单调栈了。我们这里维护的是一个单调递增的栈，即栈顶向栈底依次递减。（***注意栈本身的性质~***）

我们先给出最后期望，求出结果的方式。

```c++
            res = max( res,(right[i]-left[i]-1)*heights[i] );
```

向上逆推，推出整个过程：

```c++
            while( !stack.empty() && heights[ stack.top() ]>=heights[i] )
            {
                right[ stack.top() ] = i;
                stack.pop();
            }
            if( stack.empty() ) left[i] = -1;
           		 else left[i] = stack.top();
            stack.push(i);
```

（当然，如果是自己想的话，还是把他们左右分开来计算更好些~~）