[TOC]

# 动态规划

## Basic knowledge

Skip.

## e.g.

### [面试题 17.21. 直方图的水量](https://leetcode-cn.com/problems/volume-of-histogram-lcci/)

给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

------

**思路分析：** 动态规划的思想。显然每一列的最高可达高度取决于它的左右最短。这意味着我们在每一次都需要向两边看。
$$
x[i] = min(left,right)-height[i]
$$
我们这里需要维护两个变量，left( max )和right( max )。

```c++
            left[i] = max( left[i-1],height[i] );
            right[i] = max( right[i+1],height[i] );
```

<img src=".\image\DP_01.png" style="zoom:50%;" />

***TOO BAD!***

Improvement: We don't need `left[n],right[n]` which may waste too much space!
$$
leftMax \leftarrow leftMaxCurrent
\\
rightMax \leftarrow rightMaxCurrent
$$
我们每次只获取当前的值。动态更新left_max 和 right_max。

```c++
while( leftCurrent<rightCurrent )
        {
            if( height[leftCurrent]<height[rightCurrent] )
            {
                leftMaxCurrent = max( height[leftCurrent],leftMaxCurrent );
                res += leftMaxCurrent-height[leftCurrent];
                leftCurrent++;
            }
            else
            {
                rightMaxCurrent = max( height[rightCurrent],rightMaxCurrent );
                res += rightMaxCurrent-height[rightCurrent];
                rightCurrent--;
            }
        }
```

（思考这里if中的条件的理由。——<font size = 2>因为有可能左边后边就是右边，即遇到左右靠近的情形，否则就会出现水由高处向低处流的情形</font>）

------

当然，还有一种解法——单调栈。见单调栈笔记。





### [639. 解码方法 II](https://leetcode-cn.com/problems/decode-ways-ii/)

一条包含字母 A-Z 的消息通过以下的方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'了，字符'*'可以被当做1到9当中的任意一个数字。
```

给定一条包含数字和字符'*'的加密信息，请确定解码方法的总数。

同时，由于结果值可能会相当的大，所以你应当对109 + 7取模。（翻译者标注：此处取模主要是为了防止溢出）

```
输入: "*"
输出: 9
解释: 加密的信息可以被解密为: "A", "B", "C", "D", "E", "F", "G", "H", "I".
```

------

经典的动态规划——备忘录思路。该题的备忘录思想比较简单，关键是对于递推关系的建立。

```c++
const int MOD = pow(10, 9) + 7;
class Solution {
public:
    int numDecodings(string s) {
        if( s.size() == 0 || s[0] =='0' ) return 0;
        int n = s.size();
        vector<int> dp(n+1);
        dp[0] = 1;

        if( s[0]=='*' ) dp[1] = 9;
        else dp[1] = 1;

        for( int i = 2;i <= n;i++ )
        {
            if( s[i-1]=='*' )
            {
                //  f(n)*9
                dp[i] = (dp[i]+dp[i-1]*9LL)%MOD;
                //  consider s[i-2]
                if( s[i-2] == '*' ) dp[i] = ( dp[i]+dp[i-2]*15LL )%MOD; // why 15?
                else if( s[i-2] == '1' ) dp[i] = ( dp[i]+dp[i-2]*9LL )%MOD;
                else if( s[i-2] == '2' ) dp[i] = ( dp[i]+dp[i-2]*6LL )%MOD;
            }
            else
            {
                if( s[i-1] != '0' ) dp[i] += dp[i-1]%MOD;
                //  consider s[i-2]
                if( s[i-2] == '1' || ( s[i-2] == '2' && s[i-1]-'0'<=6 ) ) dp[i] = (dp[i]+dp[i-2])%MOD;
                if( s[i-2] == '*' )
                {
                    //  1x
                    if( s[i-1]-'0' > 6 ) dp[i] = (dp[i]+dp[i-2])%MOD;
                    else dp[i] = ( dp[i]+dp[i-2]*2LL )%MOD;
                }
            }
        }
        return dp[n];
    }
};
```

我们不妨记$s[0:n] = s[0:(n-1)]+\delta$，分类：

$1^{o}$ $\delta = '*'$

显然有$dp[n-1]$的部分。那么$dp[n-2]$的部分该怎么考虑呢？

我们考虑$s[n-1]$，即我们考虑$\overline{s[n-1]\cdot\delta}$能否构成一个有意义的符号，即$s[n-1]$为1，为2，或者为`"*"`。

注意这里第三种情况我们视为前两种的***加和***。换言之，我们对于产生相同结果的不同表达式是**看成不同的解的。**

$2^{o}$ $\delta \not= '*'$

同理。稍有不同的是$s[n-1] ='*'$的情况。核心还是看$\overline{s[n-1]\cdot\delta}$能否构成有意义的符号，这个时候我们对于$\delta$是否超过6进行进一步的细分。





### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
```

---

一种显然的方法是DFS。注意这里的数字是可以无限重复的。换句话说，我们回溯的时候没必要记住开始的位置，直接从头再来就OK。我们又加了一个cache缓存。

```c++
       	int res = 0;
        if( dp[target] != -1 ) return dp[target];
        for( auto& n:nums )
        {
            if( n>target ) break;
            else if( n==target )
            {
                res++;
                break;
            }
            else
                res += DFS( nums,target-n );//  the number can repeat!
        }
        dp[target] = res;
        return res;
```

下面我们考虑动态规划。我们可以参考锯钢条的例子。使用数组存储：$dp[0:target]$。其中，我们有：
$$
dp[i] = dp[j]+nums[k],
i > j
$$




### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```
输入：[1,2,3,1]
输出：4
	解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
	偷窃到的最高金额 = 1 + 3 = 4 。
```

------

典型的dp问题，dp的思路：
$$
dp[i] = max( dp[i-2]+nums[i],dp[i-1] )
$$
处理好边界（开头两个）就OK了。
可以在空间上进一步优化：我们不难发现，我们需要的只是前两个的值，因此，我们只需要动态地保存这两个值就可以了。

```c++
        int n = nums.size();
        int first = nums[0];
        int second = max( nums[0],nums[1] );
        for( int i = 2;i != n;i++ )
        {
            int temp = second;
            second = max( second,first+nums[i] );
            first = temp;
        }
        return second;
```

### [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)

给你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

```
输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
```

------



### [停在原地的方案数](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/)

有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。

每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。

给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。

由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。

---

答案的思路很简单：

$dp[i][j]$表示i步，***<u>走到下标j</u>***的方案数。递推关系是显然的：
$$
dp[i][j] = dp[i-1][j-1]+dp[i-1][j]+dp[i-1][j+1]
$$
然而我当时在做的时候，思路却没转过来，当时想的是$dp[i][j]$就表示i步，***<u>j长度</u>***的方案数。我们分类是以第一步为准的。第一步不动或向右。
$$
dp[i][j] = dp[i-1][j]+dp[i-2][j-1]+dp[i-2][j]
$$
到这里和编程已经没关系了，下面就是看这两种是否是等价的。当然其实是等价的，但是两边的dp代表的含义是完全不同，在证明的时候是要做转化的。

------

当然我们是可以减少空间消耗的，因为每次只需要三个数据就可以了。

```c++
#define N 502
#define M 1000000007
class Solution {
public:
    int dp[N]={1};
    int numWays(int steps, int arrLen) {
        for(int i=1;i<=steps;++i)
        for(int j=0,now=0;j<=min(i,arrLen-1);++j)
        {
            swap(now,dp[j]);
            dp[j]=((now+dp[j])%M+dp[j+1])%M;
        }
        return dp[0];
    }
};
```



---

<center><font size = 5 color = red><B>背包问题</B></font></center>

### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"}。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3。
```

---

**分析**

我们反过来看，即含有m个0和n个1，最多可以包含多少个子集元素。这样我们用`dp[i][j]`来表示。写出递推方程：
$$
dp[i][j] = max( dp[i][j],(dp[i-zero][j-one]+1) )
$$


### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

---

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

---

回溯是比较好想的方法，考虑到解的结构（$<x_i>,i \in [1,n],s_i \in \{0,1\}$）。非常直接的思路：

```c++
    void dfs( vector<int>& nums,int target,int index,int sum )
    {
        //  边界条件    
        if( index == nums.size() )
        {
            if( target == sum ) count++;
        }
        else
        {
            //  backtracking
            dfs( nums,target,index+1,sum + nums[index] );
            dfs( nums,target,index+1,sum - nums[index] );
        }
    }
```

显然这么写是不够的，我们要考虑简化。我们使用动态规划解决这道题。我们构思一下怎么构造我们的备忘录。

这里的构造方法其实和

[一和零]: https://leetcode-cn.com/problems/ones-and-zeroes/

有异曲同工之处。和通常地记录每一个数字的情况不同，我们这里`dp[i]`的下标是和$sum$的值。如果考虑和的话，就很容易了，对于每一个数字，我们都有：
$$
dp[i] += dp[i-sum]
$$

```c++
        int sum = accumulate( nums.begin(),nums.end(),0 );
        int delta = sum - target;
        //  编号的话，一正一负相当于减去了两次
        if( delta<0 || delta%2 != 0 ) return 0;
        delta = delta/2;

        vector<int> dp( delta+1 );
        dp[0] = 1;
        for( auto& num:nums )
        {
            //  和0，1题相似，我们这里是对每一个num进行计算
            for( int i = delta;i >= num;i-- )
            {
                dp[i] += dp[i-num];
            }
        }
```

需要注意的是这里我们一开始求的是和，当我们把一个加号变成减号的时候，其实是相差了两个数值。



### [1449. 数位成本和为目标值的最大数字](https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/)


给你一个整数数组 `cost` 和一个整数 `target` 。请你返回满足如下规则可以得到的 **最大** 整数：

- 给当前结果添加一个数位（`i + 1`）的成本为 `cost[i]` （`cost` 数组下标从 0 开始）。
- 总成本必须恰好等于 `target` 。
- 添加的数位中没有数字 0 。

由于答案可能会很大，请你以字符串形式返回。

如果按照上述要求无法得到任何整数，请你返回 "0" 。

 ```
 输入：cost = [4,3,2,5,6,7,2,5,5], target = 9
 输出："7772"
 解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
  数字     成本
   1  ->   4
   2  ->   3
   3  ->   2
   4  ->   5
   5  ->   6
   6  ->   7
   7  ->   2
   8  ->   5
   9  ->   5
 ```

---

还是经典的背包问题。（○|￣|_）这里多了一个对于原先的个数，实现了一个到`string`的转变。

事实上，对于背包类问题，难点在于一个遍历以及更新备忘录的顺序。

```c++
 for( int i = 0;i != n;i++ ) // for each c in cost
        {
            for( int j =1;j <=target;j++ )
            {
             if( j>=cost[i] && dp[j-cost[i]]!="#" )
                dp[j] = getMaxString( dp[j],to_string(i+1)+dp[j-cost[i]] );
            }
        }
        if( dp[target] == "#" ) return "0";
        else return dp[target];
```

### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。

---

暴力显然可以解决，但是很烂。我们这里首先考虑前缀和：
$$
sum(i,j) = presum(j)-presum(i-1)
$$
这样子，我们就可以将暴力的结果降低一维。我们继续优化。

我们想：如果我能知道每个前缀和对应的次数，是不是就可以简化了？答案是可以的。如果我们知道$presum(i),presum(i+k)$存在，我们就可以放心的加上$presum(i)$了。（**理解！**）

```c++
        for( auto&n:nums )
        {
            preSum += n;
            if( map.find( preSum-k ) != map.end() ) cnt += map[preSum-k];

            map[preSum]++;
        }
```

这个逻辑是完美的。关键是开头的值怎么设置？我们这里只需要设置`map[0] = 1`即可。