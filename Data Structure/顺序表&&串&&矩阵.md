# 顺序表&&串&&特殊矩阵

[TOC]



## 顺序表&&串


$$
\begin{cases}
Polymomial
\\
Sparse \ Matrix
\\
KMP
\end{cases}
$$

### Polynomial

$Operations?$

<font color = red>**$3*representations$:**</font>

### Sparse Matrix

$How \ to \ store? \to <row,column,value>$

<img src=".\image\array_01.png" style="zoom: 33%;" />

What about the **TRANSPOSE** operation?

(**THINKING**) 困难在哪里？复杂度？为什么？( $O(cols * terms)$ )

假定我们只学过数组，难度在于对于元素找到指定的下标！

------

<font color = red>$FastTranspose$</font>

（有点类似**MapReduce**的思路）

`rowSize[],rowStart[]` $is \ needed.$

**Step 1**:

```c++
rowSize[smArray[i].col]++;
rowStart[i] = rowStart[i-1] + rowSize[i-1];
```

$(Similar \ to \ mapping!)$

**Step 2**:

$exchange \ values \to (similar \ to \ reducing)$

$ O(terms*cols) \to O(cols+rows)!$



### $\star$KMP

主要是想法和部分变量函数的定义。

<img src=".\image\array_02.png" style="zoom: 33%;" />

（1）产生所谓多余操作的原因：当发现失配时，需要从头开始回溯。这是没有必要的。

（2）如何证明？$\to$ **反证**（How？）思考如何试图推翻这个算法？

只有**跳过头**的情况是需要考虑的！这是一个优化算法，因此我们只需要考虑某些步骤是否可以省略。

- 我们只移动`p`的index `j <- next[j]`，`s`的指针`i`保持不变。next为最大失配位置（`next[j] = k`表示`substr(p,0,k-1) == substr(p,,j-1-length,j-1)`），即从`j`位置开始和`next[j]`的位置开始比较。

  ```c++
   while(j < len - 1)
      {
          if(k == -1 || p[j] == p[k])
          {
              ++j;
              ++k;
              next[j] = k;
          }
          else
          {
              k = next[k];
          }
      }
  ```

  最终的算法为：

  ```c++
      while(i < n)
      {
          if(j == -1 || s[i] == pattern[j])
          {
              ++i;++j;
          }
          else
          {
              j = next[j];
          }
  
          if(j == patternLen)
          {
              ans = i - patternLen;
              break;
          }
      }
  ```

  

## Array && Matrix

### [搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**思路分析**

<img src=".\image\2D_matrix.png" style="zoom: 50%;" />

作为变式，和Ⅰ有明显的不同。Ⅰ中，矩阵是严格递增的，此处不是。

我们可以将左上角看成A区域，右下角看成B区域，图中的箭头表示了数字大小增加的方向。

我们从左下角开始（对称的右上角也可）遍历。

> 还有另一种解释，即每一个节点，上方比它小，右方比它大，等价于L型的BST。

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if( matrix.empty() || matrix[0].empty() ) return false;
        int x = matrix.size()-1;
        int y = 0;

        while( x>=0 && y<matrix[0].size() )
        {
            if( matrix[x][y]>target ) x--;
            else if( matrix[x][y]<target ) y++;
            else return true;
        }
        return false;       
    }
};
```

### [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

给你一个整数数组 `nums` ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的**最短**子数组，并输出它的长度。

```
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```

---

我们可以将最终的结果分为三段：$<nums_1,nums_2,nums_3>$。当我们对于第二段排好序以后，我们就有了整个有序的数组。

有一个显然的等式关系：
$$
nums_1[i]\le nums_1[left-1]\le \min\{nums_2\}< \max\{nums_2\}\le nums_3[right+1]
$$

- 官方给出的题解是将左右两个端点分开来看待：对于`left`，要小于它右边的所有值（最小值）。`right`则正好反过来。因此，其实两次***互 不 相 关 的 遍 历***我们可以在*一次*遍历就完成。

  ```c++
          for( int i = 0;i != n;i++ )
          {
              //	first right
              if( maxVal<=nums[i] ) maxVal = nums[i];
              else right = i;
              
              //	then left
              if( minVal>=nums[n-1 - i] ) minVal = nums[n-1-i];
              else left = n-1-i;
          }
  ```

