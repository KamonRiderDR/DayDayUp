# OS review

$$
DR \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 2021/9/17\\
nobody\ \ \ \ \ \ \ \ \ \ 2020/6/16\\--------------Content--------------
$$

[TOC]

## chp1 Intro

### 1.1	åŸºæœ¬æ¦‚å¿µ

==æ“ä½œç³»ç»Ÿæ¦‚å¿µï¼š==æœ¬è´¨æ˜¯**ç¨‹åºé›†**

Â·Â·Â·Â·Â·Â·æ˜¯ä¸€ç§**æ¥å£ç¨‹åºã€åˆ†é…ç¨‹åºã€æ§åˆ¶ç¨‹åºã€å†…æ ¸ç¨‹åº**

> programï¼šæœ¬è´¨æ˜¯ç¨‹åºé›†ï¼ˆæ“ä½œç³»ç»Ÿæ˜¯ä¸€ç§è½¯ä»¶ï¼‰
>
> interfaceï¼šå¯¹ç”¨æˆ·è€Œè¨€çš„ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡æ“ä½œç³»ç»Ÿä½¿ç”¨ç¡¬ä»¶èµ„æº
>
> allocationï¼ˆåˆ†é…**èµ„æº**ï¼‰ï¼šåšåˆ†é…ï¼Œå“ªéƒ¨åˆ†èµ„æºç»™ç”¨æˆ·ä½¿ç”¨
>
> controlï¼ˆæ§åˆ¶**ç¨‹åº**æ‰§è¡Œï¼‰ï¼šå¤šä¸ªç¨‹åºéƒ½æƒ³ä½¿ç”¨åŒä¸€ä¸ªèµ„æº
>
> kernelï¼šä¼´éšè®¡ç®—æœºè¿è¡Œè€Œè¿è¡Œï¼Œå”¯ä¸€ä¸å¯æˆ–ç¼º

==æ“ä½œç³»ç»ŸåŸºæœ¬ç›®æ ‡ï¼š==**æ–¹ä¾¿æ€§**ï¼ˆå¯¹ç”¨æˆ·ï¼‰ã€**é«˜æ•ˆæ€§**ï¼ˆå¯¹èµ„æºï¼‰



### 1.2	ä¸­æ–­

ä¸­æ–­æ˜¯èƒ½å¤Ÿå¼•èµ·æ“ä½œç³»ç»Ÿæ³¨æ„çš„ä¸€ç§äº‹ä»¶ï¼Œè¯¥äº‹ä»¶èƒ½å¤Ÿé©±åŠ¨æ“ä½œç³»ç»Ÿè¿›è¡Œå·¥ä½œã€‚

- è½¯ä¸­æ–­æ˜¯ç”±**ç¨‹åºæ‰§è¡Œä¸­æ–­æŒ‡ä»¤**äº§ç”Ÿçš„ï¼Œè½¯ä¸­æ–­çš„å‘ç”Ÿæ˜¯æœ‰åºçš„ã€å¯æ§çš„ã€‚
- ç¡¬ä¸­æ–­æ˜¯ç”±**å¤–è®¾**å¼•å‘çš„ï¼Œç¡¬ä¸­æ–­çš„å‘ç”Ÿæ˜¯éšæœºçš„ã€çªå‘çš„ã€‚

**ä¸­æ–­æœºåˆ¶å¦‚ä½•å·¥ä½œ**

> æ“ä½œç³»ç»Ÿæ˜¯ç”±**ä¸­æ–­é©±åŠ¨**å·¥ä½œçš„ï¼Œå½“äº§ç”Ÿä¸€ä¸ªä¸­æ–­æ—¶ï¼Œå½“å‰æ­£åœ¨æ‰§è¡Œçš„ç¨‹åºè¢«æŒ‚èµ·ï¼ŒåŒæ—¶ä¿ç•™å½“å‰çŠ¶æ€ï¼Œç³»ç»Ÿæ§åˆ¶æƒäº¤ç»™æ“ä½œç³»ç»Ÿï¼Œæ“ä½œç³»ç»Ÿé€šè¿‡æŸ¥æ‰¾**ä¸­æ–­å‘é‡**è°ƒç”¨ç›¸åº”çš„**ä¸­æ–­å¤„ç†ç¨‹åº**ã€‚ä¸­æ–­å¤„ç†ç»“æŸåè¿”å›è¢«æŒ‚èµ·çš„ç¨‹åºç»§ç»­æ‰§è¡Œã€‚

**ä¸­æ–­å‘é‡ interrupt vector**

åŒ…å«ä¸­æ–­å¤„ç†ç¨‹åºçš„å…¥å£**åœ°å€**

**ä¸­æ–­å¤„ç†ç¨‹åº interrupt service routine**

å¤„ç†ä¸­æ–­çš„ï¼Œé¢„å…ˆç¼–å†™å¥½çš„ç¨‹åº



### 1.3	å­˜å‚¨ç»“æ„

å†…å­˜ï¼ˆ**å°ï¼Œæ˜“å¤±**ï¼‰ã€äºŒçº§å­˜å‚¨ï¼ˆ**å¤§ï¼Œéæ˜“å¤±**ï¼‰ã€åˆ†å±‚ç»“æ„

CPUç›´æ¥è®¿é—®ä¸»å­˜Â·Â·Â·Â·Â·Â·Â·Only large storage media that the CPU can access directly

> Cache Coherencyï¼šç¼“å­˜ä¸€è‡´æ€§é—®é¢˜
>
> æ˜¯æŒ‡åœ¨é‡‡ç”¨**å±‚æ¬¡**ç»“æ„å­˜å‚¨ç³»ç»Ÿçš„è®¡ç®—æœºç³»ç»Ÿä¸­ï¼Œä¿è¯é«˜é€Ÿç¼“å†²å­˜å‚¨å™¨ä¸­æ•°æ®ä¸ä¸»å­˜å‚¨å™¨ä¸­æ•°æ®ç›¸åŒæœºåˆ¶



### 1.4	I/Oç»“æ„

I/Oè®¾å¤‡å’ŒCPUå¯ä»¥åŒæ—¶å·¥ä½œ

**è®¾å¤‡æ§åˆ¶å™¨**

- Each **device controller** is in charge of a particular device type and has a **local buffer**. I/O is from the device to **local buffer** of the device controller. CPU moves data from/to main memory to/from local buffers.

- è¿™ç§ä¸­æ–­é©±åŠ¨çš„I/Oé€‚åˆç§»åŠ¨**å°‘é‡æ•°æ®**

**DMA**

- Device controller directly transfers blocks of data between buffer storage and main memory **without CPU intervention**. Only **one** interrupt is generated per block.
- CPUç»™äºˆæ§åˆ¶å™¨ä¸‰æ¡æ¶ˆæ¯ã€**disk address, memory address for storing the block, byte count**ã€‘åå°±å¯ä»¥ä¸å†å¹²é¢„



### 1.5	ç¡¬ä»¶ä¿æŠ¤

åŒæ¨¡å¼ä¿æŠ¤ã€CPUä¿æŠ¤ã€å†…å­˜ä¿æŠ¤ã€I/Oä¿æŠ¤

- CPUä¿æŠ¤æœºåˆ¶çš„ç›®çš„æ˜¯é˜²æ­¢æ“ä½œç³»ç»Ÿå› **ç”¨æˆ·ç¨‹åºé•¿æœŸå ç”¨**è€Œ**å¾—ä¸åˆ°CPUèµ„æº**ï¼Œå¯é€šè¿‡==å®šæ—¶å™¨==æ¥å®ç°ã€‚(åˆ†æ—¶ç³»ç»Ÿ)
- å†…å­˜ä¿æŠ¤æœºåˆ¶çš„ç›®çš„æ˜¯ç¡®ä¿**æ¯ä¸€è¿›ç¨‹çš„å†…å­˜åœ°å€ç©ºé—´ä¸è¢«å…¶ä»–è¿›ç¨‹è®¿é—®**ï¼Œå¯é€šè¿‡==åŸºå€å¯„å­˜å™¨å’Œç•Œé™å¯„å­˜å™¨==æ¥å®ç°ã€‚
- I/Oä¿æŠ¤æœºåˆ¶çš„ç›®çš„æ˜¯**é˜²æ­¢I/Oè®¾å¤‡è¢«ç”¨æˆ·ç¨‹åºç ´å**ï¼Œå¯é€šè¿‡å°†**æ‰€æœ‰**I/Oæ“ä½œæŒ‡ä»¤==è®¾ç½®ä¸ºç‰¹æƒæŒ‡ä»¤==æ¥å®ç°ã€‚

**åŒæ¨¡å¼ä¿æŠ¤**Â·Â·Â·Â·Â·Â·Â·user modeã€kernel mode

æ¨¡å¼ä½è§„å®šÂ·Â·Â·Â·Â·Â·Â·kernel(0), user(1)

ä¸€æ—¦ä¸­æ–­äº§ç”Ÿï¼Œç¡¬ä»¶å°±ä»ç”¨æˆ·æ€åˆ‡æ¢åˆ°å†…æ ¸æ€

**ç‰¹æƒæŒ‡ä»¤**

ä¸€äº›æœºå™¨æŒ‡ä»¤å¯èƒ½ä¼šç ´åç³»ç»Ÿï¼Œä¸ºäº†é¿å…ç ´åï¼Œå¿…é¡»åœ¨å†…æ ¸æ¨¡å¼ä¸‹æ‰§è¡Œ

å¸¸è§ç‰¹æƒæŒ‡ä»¤ï¼šload-timer, load base registers, load limit registers, all I/O instructions



### 1.6	å¤šé“ç¨‹åºè®¾è®¡

> ä¸€äº›ä»»åŠ¡è¢«åŒæ—¶æ”¾ç½®åœ¨å†…å­˜ä¸­ï¼ŒCPUé€‰ä¸€ä¸ªæ‰§è¡Œï¼Œè‹¥å½“å‰çš„ä»»åŠ¡éœ€è¦ç­‰å¾…ï¼ŒCPUåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªä»»åŠ¡

Itâ€™s the **first instance** where the operating system must make decisions for the users

å¤šé“ç¨‹åºè®¾è®¡çš„**å¥½å**ï¼š

- è°ƒé«˜CPUåˆ©ç”¨ç‡ï¼Œå……åˆ†å‘æŒ¥å¹¶å‘æ€§ï¼ˆåŒ…æ‹¬ç¨‹åºé—´ã€è®¾å¤‡é—´ã€è®¾å¤‡å’ŒCPUé—´å‡å¹¶å‘å·¥ä½œï¼‰
- ç”¨æˆ·ç‹¬å èµ„æºï¼Œæ— äº¤äº’æ€§ï¼Œå»¶è¿Ÿå¤§

**ç°ä»£æ“ä½œç³»ç»Ÿå…·å¤‡çš„å››å¤§ç‰¹å¾**

- å¹¶å‘æ€§ï¼ˆConcurrenceï¼‰ï¼šç¨‹åºä¸ç¨‹åºä¹‹é—´ã€è®¾å¤‡ä¸è®¾å¤‡ä¹‹é—´ã€è®¾å¤‡ä¸CPUä¹‹é—´å‡å¯ä»¥å¹¶å‘å·¥ä½œã€‚
- å…±äº«æ€§ï¼ˆSharingï¼‰ï¼šç³»ç»Ÿä¸­çš„èµ„æºå¯ä»¥ä¾›å¤šä¸ªç¨‹åºå…±åŒä½¿ç”¨ã€‚
- è™šæ‹Ÿæ€§ï¼ˆVirtualï¼‰ï¼šå†…å­˜ä¸­çš„ç¨‹åºéƒ½è®¤ä¸ºè‡ªå·±â€œç‹¬äº«â€ç¡¬ä»¶èµ„æºï¼ŒæŠŠä¸€å°ç‰©ç†è®¾å¤‡å˜æˆé€»è¾‘ä¸Šçš„å¤šå°è®¾å¤‡ã€‚
- å¼‚æ­¥æ€§ï¼ˆAsynchronismï¼‰ï¼šç¨‹åºçš„æ‰§è¡Œæ˜¯æ— åºçš„ã€éšæœºçš„ã€‚



## chp2 OS structures

*æ“ä½œç³»ç»Ÿçš„åŠŸèƒ½ï¼š*è¿›ç¨‹ï¼ˆCPUï¼‰ç®¡ç†ã€å†…å­˜ç®¡ç†ã€æ–‡ä»¶ç®¡ç†ã€ç£ç›˜ç®¡ç†ã€I/Oç®¡ç†ã€**ç”¨æˆ·æ¥å£**

**æ“ä½œç³»ç»Ÿçš„æœåŠ¡ï¼š**ğŸ·

- ç¨‹åºæ‰§è¡Œï¼šç³»ç»Ÿå¯ä»¥å°†ç¨‹åºåŠ è½½è¿›å†…å­˜å¹¶æ‰§è¡Œ
- I/Oæ“ä½œï¼šç”¨æˆ·ç¨‹åºä¸èƒ½ç›´æ¥æ‰§è¡ŒI/Oæ“ä½œï¼Œæ‰€ä»¥OSè¦æä¾›ä¸€äº›æ”¯æŒI/Oçš„æ–¹æ³•
- æ–‡ä»¶ç³»ç»Ÿæ“ä½œï¼šç¨‹åºå¯ä»¥è¯»ã€å†™ã€åˆ›å»ºã€åˆ é™¤æ–‡ä»¶
- é€šä¿¡ï¼š**è¿›ç¨‹é—´**äº¤æ¢ä¿¡æ¯ï¼ˆå…±äº«å†…å­˜ã€æ¶ˆæ¯ä¼ é€’ï¼‰
- é”™è¯¯æ£€æµ‹ä¸å¤„ç†ï¼šæ£€æµ‹ç¡¬ä»¶ã€ç”¨æˆ·ç¨‹åºçš„é”™è¯¯
- *èµ„æºåˆ†é…*
- *ç»Ÿè®¡ï¼ˆå®¡è®¡accountingï¼‰*ï¼šäº§ç”Ÿæ—¥å¿—
- *ä¿æŠ¤*ï¼šä¿è¯è®¿é—®ç³»ç»Ÿèµ„æºçš„æ“ä½œæ˜¯å—æ§åˆ¶çš„ï¼Œæ£€æµ‹break-ins....

**åŠŸèƒ½å’ŒæœåŠ¡çš„å…³ç³»**â­

åŠŸèƒ½æ˜¯**å¯¹å†…**è€Œè¨€ï¼ŒæŒ‡**è‡ªèº«å…·å¤‡**çš„ä¸€ç§**èƒ½åŠ›**ã€‚æœåŠ¡æ˜¯**å¯¹å¤–**è€Œè¨€ï¼ŒæŒ‡**æ»¡è¶³å¤–éƒ¨éœ€æ±‚**çš„ä¸€ç§èƒ½åŠ›ï¼Œè¿™ç§èƒ½åŠ›**å¹¶éå®Œå…¨è‡ªèº«å…·å¤‡**ï¼Œå¯ä»¥é€šè¿‡**è°ƒç”¨å…¶ä»–æœåŠ¡**æ¥å®ç°ã€‚



### 2.1	ç³»ç»Ÿè°ƒç”¨

> ç³»ç»Ÿè°ƒç”¨æ˜¯**æ“ä½œç³»ç»Ÿå¯¹ç¨‹åºæ‰€æä¾›çš„æœåŠ¡çš„å®ç°å½¢å¼**ã€‚
>
> ç³»ç»Ÿè°ƒç”¨æ˜¯ä¸€äº›å¯ä»¥å‘å¤–æä¾›æ“ä½œç³»ç»ŸæœåŠ¡å’Œèµ„æºçš„å‡½æ•°ã€‚æ˜¯ç”¨æˆ·æ€çš„ç¨‹åºè®¿é—®å†…æ ¸æ€ç¨‹åºçš„æ¥å£

**å‚æ•°ä¼ é€’**ï¼ˆä¼ é€’å‚æ•°åˆ°æ“ä½œç³»ç»Ÿçš„é€šç”¨æ–¹æ³•ï¼‰

1. é€šè¿‡**å¯„å­˜å™¨**ï¼ˆæœ€ç®€å•ï¼‰
2. é€šè¿‡**å†…å­˜ä¸­çš„å—å’Œè¡¨**(**address** of block passed as a parameter in a register)
3. é€šè¿‡**å †æ ˆ**

**ç³»ç»Ÿè°ƒç”¨ç±»å‹**ğŸ·

Process control, File management, Device management, Information maintenance, Communications.

**ä¸ºä»€ä¹ˆæ›´å–œæ¬¢ç”¨APIç¼–ç¨‹ï¼Ÿ**

> **API**æ˜¯åº”ç”¨ç¨‹åºå¼€å‘äººå‘˜**ç¼–å†™ç¨‹åºæ‰€ä½¿ç”¨çš„åº”ç”¨ç¼–ç¨‹æ¥å£**ã€‚
>
> ä½¿ç”¨APIç¼–ç¨‹æœ‰å¦‚ä¸‹ä¼˜åŠ¿ï¼š
>
> - å¯ç§»æ¤ï¼šAPIå¯¹äºæŸäº›ç³»ç»Ÿè°ƒç”¨å®ç°äº†å¾ˆå¥½çš„å°è£…ï¼Œæé«˜ç¼–ç¨‹æ•ˆç‡ã€‚
> - å¯ç»´æŠ¤æ€§ï¼šå½“å¯¹æ“ä½œç³»ç»ŸåŠŸèƒ½è¿›è¡Œç»´æŠ¤å’Œä¿®æ”¹æ—¶ï¼Œä¸»è¦APIä¸å˜ï¼Œæ— éœ€ä¿®æ”¹ç”¨æˆ·ç¨‹åºã€‚
> - å®ç”¨æ€§ï¼šä¸€ä¸ªç®€å•çš„ç¨‹åºéœ€è¦å¤§é‡çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå®ç°å¯¹å¤šä¸ªç³»ç»Ÿè°ƒç”¨çš„å°è£…ï¼Œéšè—ç³»ç»Ÿè°ƒç”¨è¿‡ç¨‹ä¸­çš„å¤æ‚ç»†èŠ‚ï¼Œæ–¹ä¾¿ç”¨æˆ·çš„ä½¿ç”¨ã€‚
> - æé«˜æ€§èƒ½ï¼šå¯ä»¥å‡å°‘ä»ç”¨æˆ·ç©ºé—´åˆ°å†…æ ¸ç©ºé—´åˆ‡æ¢çš„æ¬¡æ•°å’Œå¼€é”€ã€‚



### 2.2	å¾®æ ¸ç»“æ„

æä¾›å°‘é‡çš„**ã€è¿›ç¨‹ç®¡ç†ã€å†…å­˜ç®¡ç†ã€é€šä¿¡åŠŸèƒ½ã€‘**â­ï¼ˆä¹Ÿæ˜¯å†¯è¯ºä¾æ›¼è§„å®šï¼Œä¸å¯æˆ–ç¼ºçš„â€¦â€¦ï¼‰

å®ƒçš„ä»»ä¸€æ¨¡å—éƒ½èƒ½è°ƒç”¨ä»»ä½•å…¶ä»–æ¨¡å—ï¼Œæé«˜äº†ç³»ç»Ÿæ•ˆç‡

ä¼˜ç¼ºç‚¹ï¼š

- å®¹æ˜“æ‰©å±•ï¼ˆåŠ¨æ€åŠ è½½å†…æ ¸ï¼Œæé«˜æ•ˆç‡ï¼‰ï¼Œéƒ¨ç½²ï¼Œæ›´å¯é å®‰å…¨
- ç”¨æˆ·ç©ºé—´ä¸å†…æ ¸ç©ºé—´çš„äº¤æµæ€§èƒ½å·®



### 2.3	ç­–ç•¥ä¸æœºåˆ¶åˆ†ç¦»

> æœºåˆ¶æ˜¯æ–¹æ³•ï¼Œç±»ä¼¼å‡½æ•°ï¼›ç­–ç•¥æ˜¯å‚æ•°ï¼Œä¸åŒçš„å‚æ•°ä¼šæœ‰ä¸åŒçš„ç»“æœ



## chp3 Process

### 3.1	è¿›ç¨‹

**æ¦‚å¿µ**

è¿›ç¨‹æ˜¯æŒ‡æ‰§è¡Œä¸­çš„ç¨‹åºã€‚

**ç»„æˆ**

- text section	(program code)
- program counter    (ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€)
- **contents** of the **processor's registers**
- heap-stack     (function parameters, return address, local variables)
- data section    (global variables)

(ç¬¬äºŒã€ä¸‰æ¡ç»„æˆä½“ç°äº†è¿›ç¨‹çš„**åŠ¨æ€æ€§**)

**ç‰¹å¾**

- Dynamic (åŠ¨æ€æ€§)  


- Independency (**ç‹¬ç«‹**æ€§)ï¼šè¿›ç¨‹æœ‰ç‹¬ç«‹çš„å­˜å‚¨ç©ºé—´ï¼ˆå†…å­˜ä¿æŠ¤ï¼‰


- Concurrence (å¹¶å‘æ€§)  ï¼šæ¯ä¸ªè¿›ç¨‹ä»»åŠ¡ä¸åŒ


- Structure (ç»“æ„åŒ–) ï¼šè¿›ç¨‹æœ‰â€¦â€¦ç»“æ„ï¼ˆç»„æˆï¼‰

**è¿›ç¨‹å’Œç¨‹åºçš„åŒºåˆ«**

- ç¨‹åºæ˜¯ä¸€ç»„æŒ‡ä»¤çš„æœ‰åºé›†åˆï¼Œæ˜¯ä¸€ä¸ª**é™æ€çš„å®ä½“**ã€‚è€Œè¿›ç¨‹æ˜¯ç¨‹åºåœ¨æŸä¸ªæ•°æ®é›†ä¸Šçš„æ‰§è¡Œï¼Œæ˜¯ä¸€ä¸ª**åŠ¨æ€çš„å®ä½“**ã€‚
- è¿›ç¨‹æ˜¯ä¸€ä¸ªç¨‹åºçš„çŠ¶æ€å˜åŒ–è¿‡ç¨‹ï¼Œæœ‰è‡ªå·±çš„**ç”Ÿå‘½å‘¨æœŸ**ï¼Œæ˜¯**æš‚æ—¶**çš„ï¼Œè€Œç¨‹åºæ˜¯å¯ä»¥**æ°¸ä¹…ä¿å­˜**çš„ã€‚
- è¿›ç¨‹å’Œç¨‹åº**ä¸æ˜¯ä¸€ä¸€å¯¹åº”**çš„ï¼Œä¸€ä¸ªç¨‹åºæ‰§è¡Œåœ¨ä¸åŒçš„æ•°æ®é›†ä¸Šå°±æˆä¸ºä¸åŒçš„è¿›ç¨‹ï¼Œè€Œä¸€ä¸ªè¿›ç¨‹é€šè¿‡è°ƒç”¨å…³ç³»å¯ä»¥åŒ…æ‹¬å¤šä¸ªç¨‹åºã€‚
- è¿›ç¨‹ä¸èƒ½è„±ç¦»å…·ä½“çš„ç¨‹åºè€Œå­˜åœ¨ï¼Œè€Œç¨‹åºè§„å®šäº†ç›¸åº”è¿›ç¨‹è¦å®Œæˆçš„åŠ¨ä½œã€‚

**è¿›ç¨‹å’Œçº¿ç¨‹çš„åŒºåˆ«**

- è¿›ç¨‹æ˜¯**èµ„æºåˆ†é…**çš„åŸºæœ¬å•ä½ï¼Œ**åŒä¸€è¿›ç¨‹å†…å¤šä¸ªçº¿ç¨‹å…±äº«è¿›ç¨‹çš„èµ„æº**ï¼› 
- çº¿ç¨‹æ˜¯è¿›ç¨‹å†…çš„æ§åˆ¶æµï¼Œæ˜¯**å¤„ç†å™¨è°ƒåº¦**çš„åŸºæœ¬å•ä½ï¼›
- **çº¿ç¨‹ä¸èƒ½å•ç‹¬æ‰§è¡Œï¼Œå¿…é¡»ç»„æˆè¿›ç¨‹**ï¼Œä¸€ä¸ªè¿›ç¨‹**è‡³å°‘æœ‰ä¸€ä¸ªä¸»çº¿ç¨‹**

**çŠ¶æ€**

åŸºæœ¬çš„ä¸‰æ€ï¼šreadyã€runningã€waitingâ­

![1591952113248](_review.assets/1591952113248.png)

- new to readyï¼šè¿›ç¨‹è¢«åˆ›å»ºå¹¶è·å¾—äº†**é™¤CPUä»¥å¤–**çš„æ‰€æœ‰èµ„æº

- ready to runningï¼šå½“å¤„ç†æœºç©ºé—²æ—¶ï¼Œè¿›ç¨‹è°ƒåº¦ç¨‹åº**å¿…å°†**CPUåˆ†é…ç»™ä¸€ä¸ªå¤„äºå°±ç»ªçŠ¶æ€çš„è¿›ç¨‹

  [**ä¸ä¼šå‡ºç°çš„æƒ…å†µ**ï¼šæ²¡æœ‰è¿›ç¨‹å¤„äºrunningï¼Œå´æœ‰è¿›ç¨‹é™¤ä»¥ready]ï¼ˆè¯¾å ‚è®¨è®ºé¢˜ï¼‰

- running to waitingï¼šå¤„äºè¿è¡ŒçŠ¶æ€çš„è¿›ç¨‹åœ¨è¿è¡Œè¿‡ç¨‹ä¸­éœ€è¦ç­‰å¾…æŸä¸€äº‹ä»¶å‘ç”Ÿåæ‰èƒ½ç»§ç»­è¿è¡Œï¼Œåˆ™è¯¥è¿›ç¨‹æ”¾å¼ƒå¤„ç†æœº

- waiting to readyï¼šå¤„äºç­‰å¾…çŠ¶æ€çš„è¿›ç¨‹ï¼Œå…¶ç­‰å¾…çš„äº‹ä»¶å·²ç»å‘ç”Ÿ

- running to readyï¼šå¤„äºè¿è¡ŒçŠ¶æ€çš„è¿›ç¨‹åœ¨å…¶è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œå› åˆ†ç»™å®ƒçš„å¤„ç†æœºæ—¶é—´ç‰‡å·²ç”¨å®Œæˆ–è¢«æŠ¢å ï¼Œè€Œä¸å¾—ä¸è®©å‡ºå¤„ç†æœº

- running to terminatedï¼šè¿›ç¨‹æ‰§è¡Œç»“æŸé€€å‡ºå



tipï¼šè¿›ç¨‹éƒ½åœ¨å†…å­˜ä¸­



### 3.2	è¿›ç¨‹è°ƒåº¦

è°ƒåº¦é˜Ÿåˆ—ï¼šJob queueï¼ˆåœ¨ç³»ç»Ÿä¸­çš„å…¨éƒ¨è¿›ç¨‹çš„é›†åˆï¼‰ã€ready queueï¼ˆåœ¨å†…å­˜ä¸­çš„ï¼Œå¤„äºreadyæ€ï¼Œç­‰å¾…è¢«æ‰§è¡Œçš„è¿›ç¨‹é›†åˆï¼‰ã€device queueï¼ˆç­‰å¾…I/Oè®¾å¤‡çš„è¿›ç¨‹é›†åˆï¼‰

**è°ƒåº¦å™¨**

- é•¿æœŸè°ƒåº¦å™¨ï¼šåˆç§°ä¸º**ä½œä¸šè°ƒåº¦å™¨**ï¼Œè´Ÿè´£é€‰æ‹©å“ªäº›ä½œä¸šè¢«åŠ è½½åˆ°å†…å­˜ä¸­ã€‚

  ï¼ˆå†³å®šå¤šé“ç¨‹åºçš„degreeï¼Œå³åœ¨å†…å­˜ä¸­çš„è¿›ç¨‹æ•°é‡ï¼‰

- çŸ­æœŸè°ƒåº¦å™¨ï¼šåˆç§°ä¸º**CPUè°ƒåº¦å™¨**ï¼Œç”¨æ¥é€‰æ‹©å“ªäº›è¿›ç¨‹è·å¾—CPUçš„ä½¿ç”¨æƒã€‚ï¼ˆå¿…é¡»å­˜åœ¨çš„ï¼‰

- ä¸­æœŸè°ƒåº¦å™¨ï¼šç”¨æ¥å®ç°å†…å­˜ä¸­è¿›ç¨‹çš„æ¢è¿›æ¢å‡ºæ“ä½œã€‚

**ä¸Šä¸‹æ–‡åˆ‡æ¢**

> ä»€ä¹ˆæ˜¯ä¸€ä¸ªè¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Ÿ
>
> ä¸€ä¸ªè¿›ç¨‹çš„ä¸Šä¸‹æ–‡é€šè¿‡è¿›ç¨‹çš„PCBæ¥è¡¨ç¤ºï¼ŒåŒ…æ‹¬CPUå¯„å­˜å™¨çš„å€¼ã€è¿›ç¨‹çŠ¶æ€ã€PCã€å…¶ä»–å†…å­˜/æ–‡ä»¶ç®¡ç†ä¿¡æ¯ç­‰â€¦â€¦

- å½“CPUåˆ‡æ¢åˆ°å¦ä¸€ä¸ªè¿›ç¨‹æ—¶ï¼Œç³»ç»Ÿå¿…é¡»ä¿å­˜æ—§è¿›ç¨‹çš„çŠ¶æ€ï¼Œè¯»å–ä¹‹å‰ä¿å­˜çš„æ–°è¿›ç¨‹çš„çŠ¶æ€ã€‚
- ä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶é—´æ˜¯overheadçš„ï¼Œåœ¨åˆ‡æ¢è¿‡ç¨‹ä¸­ï¼ŒCPU does no useful work
- ä¸Šä¸‹æ–‡åˆ‡æ¢éœ€è¦ç¡¬ä»¶æ”¯æŒ



### 3.3	è¿›ç¨‹æ“ä½œ

- `fork()`ï¼šæ–°è¿›ç¨‹åˆ›å»ºï¼Œé‡æ–°åˆ†é…å†…å­˜ç©ºé—´ï¼Œä¼šæœ‰å¤åˆ¶ï¼ˆcode sectionå¿…ç„¶ä¹Ÿå¤åˆ¶ï¼‰

  fork()åï¼š

  - åœ¨çˆ¶è¿›ç¨‹ï¼Œforkè¿”å›æ–°åˆ›å»ºçš„å­è¿›ç¨‹çš„è¿›ç¨‹å·ï¼ˆå¤§äº0ï¼‰
  - åœ¨å­è¿›ç¨‹ï¼Œè¿”å›0
  - å‡ºé”™ï¼Œè¿”å›è´Ÿå€¼

- `exec()`ï¼šè¦æƒ³å­è¿›ç¨‹æ‰§è¡Œä¸åŒçš„åŠŸèƒ½ï¼Œåˆ™è°ƒç”¨ï¼ˆreplace the process's memory space with a new programï¼‰

- `exit()`ï¼šè¿›ç¨‹æ‰§è¡Œå®Œäº†å®ƒçš„æœ€åä¸€å¥è¯åï¼Œè°ƒç”¨`exit()`å‘ŠçŸ¥OSåˆ é™¤å®ƒ

- `wait()`ï¼šå­è¿›ç¨‹éƒ½æ‰§è¡Œå®Œäº†ï¼Œè¯¥è°ƒç”¨`wait()`çˆ¶è¿›ç¨‹æ‰ç»§ç»­æ‰§è¡Œ

- `abort()`ï¼šçˆ¶è¿›ç¨‹å¯ä»¥ç»ˆæ­¢å­è¿›ç¨‹æ‰§è¡Œ



### 3.4	è¿›ç¨‹é—´é€šä¿¡

ä¸¤ç§é€šä¿¡æœºåˆ¶ï¼š**å…±äº«å†…å­˜ã€æ¶ˆæ¯ä¼ é€’**

- å…±äº«å†…å­˜æœºåˆ¶é€šè¿‡**å»ºç«‹å†…å­˜ç©ºé—´**å®ç°è¿›ç¨‹é—´é€šä¿¡

- æ¶ˆæ¯ä¼ é€’æœºåˆ¶é€šè¿‡**è¿›ç¨‹é—´äº¤æ¢ä¿¡æ¯**å®ç°è¿›ç¨‹é—´é€šä¿¡

  Message passing may be either **blocking or non-blocking**, <u>blocking is considered synchronous</u>, and <u>non-blocking is considered asynchronous</u>.â­

**å…±äº«å†…å­˜â€”â€”ç”Ÿäº§è€…-æ¶ˆè´¹è€…**

**æ¶ˆæ¯ä¼ é€’â€”â€”ç›´æ¥é€šä¿¡ã€é—´æ¥é€šä¿¡**

ç›´æ¥é€šä¿¡ï¼š

- è¿›ç¨‹é—´è¦å½¼æ­¤å‘½åï¼Œè°ƒç”¨å‡½æ•°`send(P,message)`, `receive(P,message)`
- linkæ˜¯è‡ªåŠ¨åˆ›å»ºçš„ï¼Œä¸€å¯¹è¿›ç¨‹ä¸€ä¸ªlink
- linkå¯ä»¥æ˜¯å•å‘çš„ï¼Œä½†ä¸€èˆ¬æ˜¯åŒå‘çš„

é—´æ¥é€šä¿¡

- æ¶ˆæ¯çš„å‘é€ã€æ¥æ”¶è¦é€šè¿‡é‚®ç®±ï¼ˆç«¯å£ï¼‰ï¼Œwhichæœ‰ä¸ªç‹¬ç‰¹çš„IDï¼ŒåŸè¯­æ˜¯`send(box, message)`, `receive(box, message)`
- ä¸¤ä¸ªè¿›ç¨‹å¯ä»¥é€šä¿¡å½“ä¸”ä»…å½“å®ƒä»¬å…±ç”¨ä¸€ä¸ªé‚®ç®±
- ä¸€ä¸ªé“¾æ¥å¯èƒ½å’Œå¤šä¸ªè¿›ç¨‹é“¾æ¥
- æ¯å¯¹è¿›ç¨‹å¯èƒ½æœ‰å¤šä¸ªé“¾æ¥
- é“¾æ¥å•åŒå‘å‡å¯

**åŒºåˆ«**

- *å…±äº«å†…å­˜æ¯”æ¶ˆæ¯ä¼ é€’å¿«ï¼ˆå…±äº«å†…å­˜ç›´æ¥è®¿é—®ç©ºé—´ï¼Œæ¶ˆæ¯ä¼ é€’éœ€è¦é€šè¿‡å†…æ ¸åšæ¶ˆæ¯æ‹·è´ã€è½¬å‘ï¼‰*
- å…±äº«å†…å­˜æœºåˆ¶ä»…**åœ¨å»ºç«‹å…±äº«å†…å­˜åŒºåŸŸæ—¶éœ€è¦è¿›è¡Œç³»ç»Ÿè°ƒç”¨**ï¼Œä¹‹åå‡ä¸ºå¸¸è§„å†…å­˜è®¿é—®ï¼Œä¸”ä¸éœ€è¦å¤åˆ¶ä¿¡æ¯ï¼Œå› æ­¤æ¯”è¾ƒ**é€‚åˆä¼ é€’å¤§é‡æ•°æ®**ã€‚è€Œæ¶ˆæ¯ä¼ é€’æœºåˆ¶çš„å®ç°**ç»å¸¸ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨**ï¼Œä¸”éœ€è¦ä¿¡æ¯**å¤åˆ¶**ï¼Œä¼ é€’ä¿¡æ¯çš„äº‹ä»¶å¼€é”€å¤§äºå…±äº«å†…å­˜æœºåˆ¶ï¼Œ**ä¸é€‚åˆä¼ é€’å¤§é‡æ•°æ®**ã€‚
- å…±äº«å†…å­˜æœºåˆ¶é€šè¿‡**å…±äº«å˜é‡**å®ç°è¿›ç¨‹é—´é€šä¿¡ï¼Œéœ€è¦**é¢å¤–æœºåˆ¶**é˜²æ­¢è®¿é—®å†²çªå‘ç”Ÿï¼Œå› æ­¤**ä¸é€‚åˆä¼ é€’å°‘é‡æ•°æ®**ã€‚è€Œæ¶ˆæ¯ä¼ é€’æœºåˆ¶å¯ä»¥é¿å…è®¿é—®å†²çªï¼Œæ¯”è¾ƒ**é€‚åˆä¼ é€’å°‘é‡æ•°æ®**ã€‚
- ç”±äºå…±äº«å†…å­˜æœºåˆ¶å­˜åœ¨**ç¼“å­˜ä¸€è‡´æ€§**é—®é¢˜ï¼Œåœ¨**å¤šæ ¸ç³»ç»Ÿä¸­==æ¶ˆæ¯ä¼ é€’æœºåˆ¶==**å¾€å¾€æˆä¸ºè¿›ç¨‹é—´é€šä¿¡çš„**é¦–é€‰**ã€‚
- å…±äº«å†…å­˜ç³»ç»Ÿä¸­ï¼Œæä¾›é€šä¿¡çš„è´£ä»»ä¸»è¦åœ¨**åº”ç”¨ç¨‹åºå‘˜**ä¸Šï¼Œæ“ä½œç³»ç»Ÿåªéœ€æä¾›å…±äº«å†…å­˜ç©ºé—´ï¼›è€Œåœ¨æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿä¸­ï¼Œæä¾›é€šä¿¡çš„è´£ä»»ä¸»è¦åœ¨**æ“ä½œç³»ç»Ÿ**æœ¬èº«ï¼Œåº”ç”¨ç¨‹åºå‘˜æ— æ³•å¹²æ¶‰ã€‚



## chp4	Thread

### 4.1	çº¿ç¨‹

**æ¦‚å¿µ**

çº¿ç¨‹æ˜¯è¿›ç¨‹å†…çš„æ§åˆ¶æµ(a flow of control)ï¼Œæ˜¯CPUè°ƒåº¦çš„åŸºæœ¬å•ä½ã€‚

ï¼ˆåŒä¸€è¿›ç¨‹å†…çš„çº¿ç¨‹å…±äº«è¿›ç¨‹çš„èµ„æº(code section, data section, other resources)ï¼‰

**ç»„æˆ**â­

Thread ID, program counter, register set, stack

> Each thread has its separate set of register values and a separate stack.(âœ”)

**ç¨‹åºã€è¿›ç¨‹ã€çº¿ç¨‹çš„åŒºåˆ«**â­ï¼ˆè§3.1ï¼‰



### 4.2	åˆ†ç±»

**ç”¨æˆ·çº§çº¿ç¨‹**

æ²¡æœ‰å†…æ ¸çš„å¹²é¢„ï¼Œç”¨æˆ·çº§è¿›ç¨‹æ›´åŠ **é«˜æ•ˆ**

ç”±äºå†…æ ¸åªèƒ½è¯†åˆ«åŒ…å«ç”¨æˆ·çº§çº¿ç¨‹çš„è¿›ç¨‹ï¼Œè‹¥ä¸€ä¸ªçº¿ç¨‹é˜»å¡äº†ï¼ŒåŒä¸€è¿›ç¨‹çš„å…¶ä»–çº¿ç¨‹ä¹Ÿé˜»å¡äº†ã€‚

**å†…æ ¸çº§çº¿ç¨‹**

åœ¨å†…æ ¸ç©ºé—´è¿›è¡Œç®¡ç†

é˜»å¡ä¸€ä¸ªçº¿ç¨‹ä¸ä¼šå¼•èµ·åŒä¸€è¿›ç¨‹çš„å…¶ä»–çº¿ç¨‹é˜»å¡ï¼Œå†…æ ¸ simply runs other threads

> Management and Creation of the kernel threads are usually **slower** than that of the user threads.(âœ”)

**åŒºåˆ«**ï¼ˆå¯¼å­¦é—®é¢˜ç­”æ¡ˆï¼‰

- ç”¨æˆ·çº§çº¿ç¨‹ä»…å­˜åœ¨**ç”¨æˆ·ç©ºé—´**ï¼Œæ“ä½œç³»ç»Ÿå†…æ ¸**ä¸çŸ¥é“**å®ƒçš„å­˜åœ¨ï¼Œè€Œå†…æ ¸çº§çº¿ç¨‹ä½äº**å†…æ ¸ç©ºé—´**ï¼Œæ“ä½œç³»ç»Ÿå†…æ ¸**èƒ½å¤Ÿæ„ŸçŸ¥**åˆ°å®ƒçš„å­˜åœ¨ã€‚
- ç”¨æˆ·çº§çº¿ç¨‹ç”±**åº”ç”¨ç¨‹åºçº¿ç¨‹åº“**æ¥è°ƒåº¦å’Œç®¡ç†ï¼Œè€Œå†…æ ¸çº§çº¿ç¨‹ç”±**æ“ä½œç³»ç»Ÿ**æ¥è°ƒåº¦å’Œç®¡ç†ã€‚
- å„ä¸ªç”¨æˆ·çº¿ç¨‹**åªèƒ½åœ¨è¿›ç¨‹å†…**è¿›è¡Œèµ„æºç«äº‰ï¼Œè€Œå†…æ ¸çº§çº¿ç¨‹å¯ä»¥åœ¨**å…¨ç³»ç»Ÿ**å†…è¿›è¡Œèµ„æºç«äº‰ã€‚



### 4.3	å¤šçº¿ç¨‹æ¨¡å‹

å¤šå¯¹ä¸€ã€ä¸€å¯¹ä¸€ã€å¤šå¯¹å¤š

- ==å¤šå¯¹ä¸€æ¨¡å‹==ä¸­ï¼Œå¤šä¸ªç”¨æˆ·çº§çº¿ç¨‹æ˜ å°„åˆ°ä¸€ä¸ªå†…æ ¸çº§çº¿ç¨‹ã€‚**ä¸€æ¬¡åªèƒ½æœ‰ä¸€ä¸ªè¿›ç¨‹**ä¸­çš„**ä¸€ä¸ªçº¿ç¨‹**è¢«è°ƒåº¦æ‰§è¡Œï¼Œå¦‚æœè¯¥çº¿ç¨‹è¢«é˜»å¡ï¼Œé‚£ä¹ˆè¯¥çº¿ç¨‹æ‰€å±çš„æ•´ä¸ªè¿›ç¨‹éƒ½è¢«é˜»å¡ï¼Œåœ¨å¤šæ ¸ç³»ç»Ÿä¸­**æœªèƒ½ä½“ç°çœŸæ­£çš„å¹¶å‘æ€§ã€‚**

- ==ä¸€å¯¹ä¸€æ¨¡å‹==ä¸­ï¼Œä¸€ä¸ªç”¨æˆ·çº§çº¿ç¨‹æ˜ å°„åˆ°ä¸€ä¸ªå†…æ ¸çº§çº¿ç¨‹ï¼Œå¦‚æœä¸€ä¸ªçº¿ç¨‹è¢«é˜»å¡ï¼Œé‚£ä¹ˆè¯¥çº¿ç¨‹æ‰€å±è¿›ç¨‹çš„å…¶ä»–çº¿ç¨‹ä»ç„¶å¯ä»¥è¢«è°ƒåº¦æ‰§è¡Œã€‚åœ¨å¤šæ ¸ç³»ç»Ÿä¸­**æä¾›äº†æ›´å¥½çš„å¹¶å‘æ€§**ã€‚å¦‚æœç”¨æˆ·çº§çº¿ç¨‹çš„åˆ›å»ºä¸å—é™åˆ¶ï¼Œç³»ç»Ÿèµ„æºå°†è¢«**è€—å°½**ã€‚
- ==å¤šå¯¹å¤šæ¨¡å‹==ä¸­ï¼Œå¤šä¸ªç”¨æˆ·çº§çº¿ç¨‹æ˜ å°„åˆ°å¤šä¸ªå†…æ ¸çº§çº¿ç¨‹ï¼Œæ—¢èƒ½å¤Ÿæé«˜å¤šæ ¸ç³»ç»Ÿçš„å¹¶å‘æ€§ï¼Œåˆèƒ½å¤Ÿé˜²æ­¢å› ç”¨æˆ·çº§çº¿ç¨‹çš„åˆ›å»ºä¸å—é™åˆ¶è€Œé€ æˆçš„ç³»ç»Ÿèµ„æºè€—å°½ã€‚



### 4.4	çº¿ç¨‹åº“

`int pthread_create(tid, attr, function, arg)` 

åˆ›é€ ä¸€ä¸ªæ‰§è¡Œfunctionçš„çº¿ç¨‹ 

`int pthread_join(tid, val_ptr)`

ä½¿ä¸€ä¸ªçº¿ç¨‹ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹(with handle tid)ç»“æŸï¼Œæ‰ç»§ç»­æ‰§è¡Œ

**åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¢«joined**

çº¿ç¨‹çŠ¶æ€æœ‰**joinableå’Œdetached**ï¼Œåè€…can't be joined



### 4.5	ä¿¡å·æœºåˆ¶ï¼ˆå¯¹æ¯”ä¸­æ–­æœºåˆ¶ï¼‰

Signals are used in UNIX systems to **notify a process** that a particular **event has occurred**.

**All signals follow the same pattern:** 

- Signal is generated by particular event 

- Signal is delivered to a process 

- Signal is handled

> ä¿¡å·æœºåˆ¶å’Œä¸­æ–­æœºåˆ¶çš„å¼‚åŒï¼ˆè€ƒç ”ç½‘ç­”æ¡ˆï¼‰â­
>
> **åŒï¼š**éƒ½é‡‡ç”¨äº†ç›¸åŒçš„å¼‚æ­¥é€šä¿¡æ–¹å¼ï¼›å¯¹ä¿¡å·å’ŒæŸäº›ä¸­æ–­éƒ½å¯ä»¥å±è”½ï¼›éƒ½æ˜¯å¤„ç†å®Œæ¯•åå›æ¥åŸæ¥æ–­ç‚¹
>
> **å¼‚ï¼š**ä¸­æ–­æœ‰ä¼˜å…ˆçº§ï¼Œä¿¡å·æ²¡æœ‰ï¼›ä¿¡å·å¤„ç†ç¨‹åºæ˜¯åœ¨ç”¨æˆ·æ€ä¸‹è¿è¡Œçš„ï¼Œä¸­æ–­å¤„ç†ç¨‹åºæ˜¯åœ¨æ ¸å¿ƒæ€ä¸‹è¿è¡Œçš„ï¼›ä¸­æ–­å“åº”æ˜¯åŠæ—¶çš„ï¼Œä¿¡å·ç›¸åº”é€šå¸¸æœ‰è¾ƒå¤§çš„æ—¶é—´å»¶è¿Ÿã€‚



## chp5	CPU scheduling

### 5.1	CPUè°ƒåº¦

CPU scheduling is **the basis of** multiprogrammed OS

**è°ƒåº¦çš„å¯è¡Œæ€§**

- CPUè°ƒåº¦çš„æˆåŠŸå–å†³äºè¿›ç¨‹çš„å±æ€§â€”â€”â€”â€”CPU-I/O Burst Cycle

- è¿›ç¨‹çš„æ‰§è¡Œé‡å¤ç€CPU burstå’ŒI/O burst

  å½“ä¸€ä¸ªè¿›ç¨‹åœ¨I/O burstæ—¶ï¼Œå¦ä¸€ä¸ªè¿›ç¨‹å¯ä»¥ç”¨CPUè¿›è¡Œå®ƒçš„CPU Burst

- CPU-boundï¼šä¸€ä¸ªè¿›ç¨‹ç»å¤§éƒ¨åˆ†æ—¶é—´åœ¨åšè®¡ç®—ï¼Œå ç”¨CPUï¼Œæœ‰**å°‘è€Œé•¿**çš„CPU bursts

  I/O-boundï¼šä¸€ä¸ªè¿›ç¨‹ç»å¤§éƒ¨åˆ†æ—¶é—´åœ¨åšI/Oï¼Œæœ‰å¾ˆå¤š**çŸ­**çš„CPU bursts

**å‘ç”Ÿè°ƒåº¦çš„æ—¶æœº**

è¿›ç¨‹è½¬æ¢å›¾ï¼Œé™¤äº†ready->runningä¸ä¼šå‘ç”Ÿè°ƒåº¦å¤–ï¼Œå…¶ä»–è½¬æ¢éƒ½ä¼šå‘ç”ŸCPUè°ƒåº¦

**æŠ¢å å¼è°ƒåº¦å’ŒéæŠ¢å å¼è°ƒåº¦**

> åŒºåˆ«ï¼šæŠ¢å å¼è°ƒåº¦å…è®¸ä¸€ä¸ªæ­£åœ¨æ‰§è¡Œä¸­çš„è¿›ç¨‹æš‚æ—¶ä¸­æ­¢ï¼Œå°†CPUäº¤ç»™å…¶ä»–è¿›ç¨‹ã€‚éæŠ¢å å¼è°ƒåº¦ä¿è¯ä¸€ä¸ªè¿›ç¨‹åœ¨æ‰§è¡ŒæœŸé—´ä¸ä¼šè¢«å‰¥å¤ºCPUã€‚

- æŠ¢å å¼è°ƒåº¦å‘ç”Ÿåœ¨new->ready, running->ready, waiting->readyã€‚
- éæŠ¢å å¼è°ƒåº¦å‘ç”Ÿåœ¨running->waiting, running->terminated

**è°ƒåº¦å™¨**

*çœŸæ­£å»å®ç°è°ƒåº¦çš„æ˜¯åˆ†æ´¾å™¨ï¼Œè°ƒåº¦å™¨è´Ÿè´£å†³ç­–*

CPUç©ºé—²æ—¶ï¼Œè°ƒåº¦å™¨å¿…é¡»é€‰æ‹©ä¸€ä¸ªreadyçš„è¿›ç¨‹å»æ‰§è¡Œâ€”â€”â€”â€”çŸ­æœŸè°ƒåº¦å™¨ï¼ˆCPUè°ƒåº¦å™¨ï¼‰

**åˆ†æ´¾å™¨**

åˆ†æ´¾å™¨ç»™äºˆCPUé‚£ä¸ªï¼Œè¢«çŸ­æœŸè°ƒåº¦å™¨é€‰æ‹©çš„è¿›ç¨‹ï¼Œçš„æ§åˆ¶æƒ

åˆ†æ´¾å™¨åŠŸèƒ½åŒ…æ‹¬ï¼šä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œåˆ‡æ¢åˆ°ç”¨æˆ·æ€ï¼Œè·³è½¬åˆ°ç”¨æˆ·ç¨‹åºé‡å¯çš„åˆé€‚ä½ç½®

åˆ†æ´¾æ½œä¼ï¼ˆDispatch latencyï¼‰ï¼šåˆ†æ´¾å™¨åœæ­¢ä¸€ä¸ªè¿›ç¨‹ï¼Œé‡å¯å¦ä¸€ä¸ªè¿›ç¨‹æ‰€éœ€è¦çš„æ—¶é—´

**è°ƒåº¦å‡†åˆ™**

1. CPUåˆ©ç”¨ç‡(CPU Utilization)ï¼šå•ä½æ—¶é—´å†…CPU**è¢«ä½¿ç”¨**çš„**æ¯”ç‡**
   $$
   â‰¤40\%\ \ \ lightly\ loaded\ \ \ \ \ \ \ \ \ \ â‰¥90\%\ \ \ heavily\ loaded
   $$

2. ååé‡(Throughput)ï¼šå•ä½æ—¶é—´å†…**å®Œæˆè¿›ç¨‹**çš„**ä¸ªæ•°**

   ä¸CPUåˆ©ç”¨ç‡æ²¡æœ‰ç›´æ¥å…³ç³»

3. å‘¨è½¬æ—¶é—´(Turnaround Time)ï¼šä»ä¸€ä¸ª**ä»»åŠ¡æäº¤**åˆ°**ä»»åŠ¡å®Œæˆ**æ‰€éœ€è¦çš„æ—¶é—´
   $$
   turnaround\ time=finished\ time-arrival\ time
   $$

4. ç­‰å¾…æ—¶é—´(Waiting Time)ï¼šè¿›ç¨‹åœ¨**å°±ç»ªé˜Ÿåˆ—ä¸­ç­‰å¾…æ—¶é—´çš„æ€»å’Œ**

   ä¸ºä»€ä¹ˆä»…ä»…æ˜¯å°±ç»ªé˜Ÿåˆ—ï¼šå½“ä¸€ä¸ªè¿›ç¨‹æ‰§è¡Œæˆ–åšI/Oæ—¶ï¼ŒCPUè°ƒåº¦ç®—æ³•ä¸å½±å“å…¶æ‰§è¡Œæ—¶é—´ï¼›å½“è¿›ç¨‹å¤„äºå°±ç»ªé˜Ÿåˆ—ä¸­æ—¶ï¼ŒCPUè°ƒåº¦ç®—æ³•å½±å“å…¶æ—¶é—´ã€‚
   $$
   waiting\ time=finished\ time-burst\ time-arrival\ time
   $$

5. å“åº”æ—¶é—´(Response Time)ï¼šä»**æäº¤ä¸€ä¸ªè¯·æ±‚**åˆ°äº§ç”Ÿ**ç¬¬ä¸€æ¬¡å“åº”**æ‰€éœ€è¦çš„æ—¶é—´

   ä¸åŒ…æ‹¬output responseçš„æ—¶é—´



### 5.2	è°ƒåº¦ç®—æ³•

#### 1.	FCFS(First-Come-First-Served)

ç”¨é˜Ÿåˆ—å®¹æ˜“å»å®ç°ï¼Œ**ä¸æ˜¯æŠ¢å å¼è°ƒåº¦**ï¼ˆè¿›ç¨‹ä¸€æ—¦å ç”¨CPUï¼Œå°±ç›´åˆ°å®ƒterminatedæˆ–waitingï¼‰

==Convoy Effectï¼š==ï¼ˆæŠ¤èˆªæ•ˆåº”ã€è½¦é˜Ÿæ•ˆåº”ï¼‰æ‰€æœ‰è¿›ç¨‹ç­‰å¾…ä¸€ä¸ªå¤§è¿›ç¨‹æ”¾å¼ƒCPUä½¿ç”¨æƒ



#### 2.	SJF(Shortest-Job-First)

å¯ä»¥æ˜¯æŠ¢å å¼ï¼ˆShortest-Remaining-Time-Firstï¼‰/éæŠ¢å å¼è°ƒåº¦ï¼Œå¯ä»¥è·å¾—æœ€å°çš„å¹³å‡ç­‰å¾…æ—¶é—´

å¯èƒ½ä¼šäº§ç”Ÿ**é¥¥é¥¿**

æ€ä¹ˆçŸ¥é“ä¸‹ä¸€ä¸ªCPU burstçš„æ—¶é—´ï¼ŸPredictï¼Œæ ¹æ®å…ˆå‰çš„CPU burstâ€”â€”â€”â€”**exponential averagingï¼ˆæŒ‡æ•°å¹³å‡ï¼‰**
$$
Ï„_{n+1}=Î±t_n+(1-Î±)Ï„_n
$$

- t~n~ï¼šç¬¬næ¬¡CPU burstçš„æ—¶é—´
- Ï„~(n+1)~ï¼šä¼°è®¡çš„ä¸‹ä¸€ä¸ªCPU burstæ—¶é—´



#### 3.	ä¼˜å…ˆçº§è°ƒåº¦

å¯ä»¥æ˜¯æŠ¢å å¼/éæŠ¢å å¼è°ƒåº¦ï¼ˆè¯¾ä»¶è§„å®šæ•°å­—è¶Šå°è¶Šä¼˜å…ˆï¼‰ï¼Œå¯èƒ½ä¼šäº§ç”ŸIndefinite blockï¼ˆ**é¥¥é¥¿**ï¼‰

å†…éƒ¨ä¼˜å…ˆçº§ï¼šdetermined by time limits, memory requirement, number of files, etc.

å¤–éƒ¨ä¼˜å…ˆçº§ï¼šä¸æ˜¯è¢«OSæ‰€æ§åˆ¶çš„ï¼ˆä¾‹å¦‚è¿›ç¨‹çš„é‡è¦æ€§ï¼‰

**Aging**ï¼šé€æ¸æå‡é‚£äº›åœ¨ç³»ç»Ÿä¸­ç­‰å¾…è®¸ä¹…è¿›ç¨‹çš„ä¼˜å…ˆçº§



#### 4.	Round Robin è½®è½¬æ³•è°ƒåº¦

ç‰¹åˆ«ä¸ºtime-sharing systemså‡†å¤‡çš„ï¼Œç±»ä¼¼FCFSï¼Œæ¯ä¸ªè¿›ç¨‹è¢«åˆ†é…äº†ä¸€ä¸ªæ—¶é—´ç‰‡ï¼Œç”¨å®Œäº†åˆ™è‡ªæ„¿æ”¾å¼ƒCPUä½¿ç”¨ï¼Œç»§ç»­é‡å¤´æ’é˜Ÿã€‚Typicallyï¼Œ**å¹³å‡å‘¨è½¬æ—¶é—´æ›´é•¿ï¼Œä½†ç›¸åº”æ—¶é—´æ›´å¥½**ã€‚æ—¶é—´ç‰‡å¤ªé•¿â€”â€”å˜æˆFCFSï¼›æ—¶é—´ç‰‡å¤ªçŸ­â€”â€”å˜æˆå¤„ç†å™¨å…±äº«ã€‚ä¸Šä¸‹æ–‡åˆ‡æ¢å¯èƒ½å½±å“RRçš„æ€§èƒ½ï¼Œæ›´çŸ­çš„æ—¶é—´ç‰‡æ„å‘³ç€æ›´å¤šçš„ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚In generalï¼Œ**80%** CPU burstsåº”å½“å°äºæ—¶é—´ç‰‡é•¿åº¦ã€‚**å¢åŠ æ—¶é—´ç‰‡çš„é•¿åº¦ï¼Œå¹³å‡å‘¨è½¬æ—¶é—´ä¸ä¸€å®šå‡å°‘**



#### 5.	å¤šçº§é˜Ÿåˆ—è°ƒåº¦

å°±ç»ªé˜Ÿåˆ—è¢«åˆ†å‰²ä¸ºä¸åŒçš„é˜Ÿåˆ—ï¼Œæ ¹æ®è¿›ç¨‹çš„æ€§è´¨å°†å…¶**æ°¸ä¹…**åˆ†é…åˆ°ä¸€ä¸ªé˜Ÿåˆ—ä¸­

- foreground(interactive): RR
- background(batch): FCFS

ä¸€ä¸ªè¿›ç¨‹På¯ä»¥æ‰§è¡Œï¼Œå½“ä¸”ä»…å½“æ‰€æœ‰åœ¨å…¶é˜Ÿåˆ—ä¹‹ä¸Šçš„åŒ…å«Pçš„é˜Ÿåˆ—ä¸ºç©ºã€‚å½“ä¸€ä¸ªè¿›ç¨‹Qåœ¨æ‰§è¡Œï¼Œä¸€ä¸ªæ›´é«˜ä¼˜å…ˆçº§é˜Ÿåˆ—è¿›æ¥åï¼ŒQè¢«æŠ¢å ã€‚

å›ºå®šä¼˜å…ˆçº§é˜Ÿåˆ—ï¼šå¯èƒ½äº§ç”Ÿé¥¥é¥¿

æ—¶é—´ç‰‡ï¼šæ¯ä¸ªé˜Ÿåˆ—éƒ½æœ‰certain amount of CPU time



#### 6.	å¤šçº§åé¦ˆé˜Ÿåˆ—è°ƒåº¦

ç±»ä¼¼å¤šçº§é˜Ÿåˆ—ï¼Œä½†æ˜¯**å…è®¸è¿›ç¨‹åœ¨é˜Ÿåˆ—é—´ç§»åŠ¨**ï¼ˆå®ç°æ–¹æ³•ï¼šagingï¼‰ã€‚è‹¥è¿›ç¨‹På ç”¨**æ›´å¤š**CPU timeï¼Œåˆ™è¢«ç§»åŠ¨åˆ°**æ›´ä½**ä¼˜å…ˆçº§çš„é˜Ÿåˆ—ä¸­ï¼Œå› æ­¤I/O boundè¿›ç¨‹ä¼šåœ¨æ›´é«˜ä¼˜å…ˆçº§çš„é˜Ÿåˆ—ä¸­ã€‚



## chp6	Process Synchronization

### 6.1	ç«äº‰æ¡ä»¶	Race condition

â­

ç«äº‰æ¡ä»¶å‘ç”Ÿï¼Œä»…å½“ï¼š

> **ä¸¤ä¸ªæˆ–æ›´å¤š**çš„è¿›ç¨‹/çº¿ç¨‹**åŒæ—¶æˆ–å¹¶è¡Œ**åœ°**è®¿é—®ã€æ“ä½œç›¸åŒçš„æ•°æ®**ã€‚æ‰§è¡Œçš„ç»“æœå–å†³äºè®¿é—®å‘ç”Ÿçš„ç‰¹å®šé¡ºåºã€‚

éæŠ¢å å¼å†…æ ¸ä¸ä¼šæœ‰race conditions

ä¸ºäº†é˜²æ­¢ç«äº‰æ¡ä»¶ï¼ŒåŒæ—¶å’Œå¹¶è¡Œçš„è¿›ç¨‹å¿…é¡»è¦**åŒæ­¥**



### 6.2	ä¸´ç•ŒåŒºé—®é¢˜

> ä¸´ç•ŒåŒºï¼š**è¿›ç¨‹**ä¸­**åŒ…å«ä¿®æ”¹å…±äº«æ•°æ®**çš„**ä»£ç æ®µ**ã€‚

> ä¸´ç•ŒåŒºé—®é¢˜ï¼šè®¾è®¡ä¸€ä¸ª**åè®®**ï¼Œç¡®ä¿ä¸€è¿›ç¨‹åœ¨ä¸´ç•ŒåŒºæ‰§è¡Œæ—¶**ä¸å…è®¸å…¶ä»–è¿›ç¨‹åŒæ—¶ä¹Ÿåœ¨ä¸´ç•ŒåŒºæ‰§è¡Œ**ã€‚

ä¸´ç•ŒåŒºåè®®åŒ…å«ä¸¤éƒ¨åˆ†ï¼š**è¿›å…¥åŒºã€é€€å‡ºåŒº**ã€‚ä¸­é—´çš„æ˜¯**ä¸´ç•ŒåŒº**ï¼ˆäº’æ–¥è®¿é—®ï¼‰ï¼Œæœ€åè¿˜æœ‰ä¸€ä¸ª**å‰©ä½™åŒº**

ä¸´ç•ŒåŒºé—®é¢˜éœ€è¦æ»¡è¶³çš„**ä¸‰ä¸ªæ¡ä»¶**ï¼šäº’æ–¥ã€è¿›å±•ã€æœ‰é™ç­‰å¾…â­

- äº’æ–¥æ€§ï¼šå¦‚æœä¸€ä¸ªè¿›ç¨‹åœ¨ä¸´ç•ŒåŒºå†…æ‰§è¡Œï¼Œé‚£ä¹ˆå…¶ä»–è¿›ç¨‹éƒ½ä¸èƒ½åœ¨å…¶ä¸´ç•ŒåŒºå†…æ‰§è¡Œã€‚
- è¿›å±•æ€§ï¼šå¦‚æœæ²¡æœ‰è¿›ç¨‹åœ¨ä¸´ç•ŒåŒºå†…æ‰§è¡Œï¼Œè€Œä¸”æœ‰è¿›ç¨‹éœ€è¦è¿›å…¥ä¸´ç•ŒåŒºï¼Œé‚£ä¹ˆä¸€å®šä¼šæœ‰ä¸€ä¸ªè¿›ç¨‹èƒ½å¤Ÿè¿›å…¥ä¸´ç•ŒåŒºæ‰§è¡Œã€‚ï¼ˆé¿å…æ­»é”ï¼‰
- æœ‰é™ç­‰å¾…ï¼šä»ä¸€ä¸ªè¿›ç¨‹**åšå‡ºè¿›å…¥ä¸´ç•ŒåŒºçš„è¯·æ±‚**ç›´**åˆ°è¿™ä¸ªè¯·æ±‚å…è®¸ä¸ºæ­¢**ï¼Œ**å…¶ä»–**è¿›ç¨‹å…è®¸è¿›å…¥å…¶ä¸´ç•ŒåŒºçš„æ¬¡æ•°æ˜¯**æœ‰é™**çš„ã€‚ï¼ˆé¿å…é¥¥é¥¿ï¼‰



### 6.3	Petersonç®—æ³•

å¯¹ä¸¤ä¸ªè¿›ç¨‹è€Œè¨€

```c++
// process i
do{
    flag[i]=true;
    turn=j;
    while(flag[j] && turn==j);
    // critical section
    flag[i]=false;
    // remainder section
}while(1);
```

### 6.4	Bakeryç®—æ³•

å¯¹å¤šä¸ªè¿›ç¨‹è€Œè¨€

çœ‹PPT Chp6 (1)



### 6.5	ç¡¬ä»¶åŒæ­¥æœºåˆ¶ï¼ˆä¸­æ–­ç®¡ç†ï¼Œç‰¹æ®ŠæŒ‡ä»¤ï¼‰

ä¸¤ç§ç¡¬ä»¶åŒæ­¥æœºåˆ¶ï¼š**Disabling/Enabling interruptsã€ç‰¹æ®ŠæŒ‡ä»¤**ã€‚

**Interrupt Disabling**

å› ä¸ºä¸­æ–­è¢«ç¦ç”¨äº†ï¼Œ**ä¸ä¼šå‘ç”Ÿä¸Šä¸‹æ–‡åˆ‡æ¢**ã€‚åœ¨å¤šå¤„ç†å™¨ç³»ç»Ÿä¸­ä¸å¯è¡Œï¼Œå› ä¸ºæ‰€æœ‰çš„CPUéƒ½è¦è¢«é€šçŸ¥ã€‚

**TestAndSet**

Test and modify the content of a word atomically.

```c++
bool lock = false;
// process Pi
do{
    while(TestAndSet(lock)); // ç¬¬ä¸€æ¬¡è¿”å›æ˜¯falseï¼Œåé¢éƒ½æ˜¯true
    // Critical
    lock = false;
    // remainder
}
```

PPTè¿˜æœ‰ä¸€ä¸ªç®—æ³•ï¼Œçœ‹ä¸€ä¸‹ chp6 (2) page 10ï¼Œçœ‹çœ‹è§£é‡Šâ€¦â€¦



### 6.6	è½¯ä»¶åŒæ­¥æœºåˆ¶

#### 1	ä¿¡å·é‡

`wait(S):P(S)`ï¼šwhile S <= 0;	Sâ€” â€”;

`signal(S):V(S)`:	S++;

**ä¸¤ç§ç±»å‹çš„ä¿¡å·é‡ï¼š**

Counting semaphoreï¼šæ•´æ•°å€¼å¯ä»¥åœ¨æ— é™åˆ¶èŒƒå›´å†…å˜åŒ–ï¼Œç”¨æ¥å¯¹**å¤šå®ä¾‹èµ„æº**çš„åˆ†é…æ§åˆ¶

Binary semaphoreï¼šæ•´æ•°å€¼åªèƒ½åœ¨0ã€1ä¹‹é—´å˜åŒ–ï¼Œä¹Ÿå«mutex locks

Counting semaphore ä¹Ÿèƒ½ç”¨ binary semaphore æ¥å®ç°

ä¸Šè¿°ä¿¡å·é‡çš„å®šä¹‰è¦æ±‚**å¿™ç­‰**ï¼ˆæœ‰ä¸€ä¸ªè¿›ç¨‹åœ¨ä¸´ç•ŒåŒºæ—¶ï¼Œå…¶ä»–è¿›ç¨‹è¦åœ¨å®ƒä»¬çš„è¿›å…¥åŒºæŒç»­çš„å¾ªç¯åˆ¤æ–­ï¼‰ï¼Œæ‰€ä»¥è¿™ç§ä¿¡å·é‡ä¹Ÿå«spinlockï¼ˆè‡ªæ—‹é”ï¼‰

å¥½å¤„ï¼šæ²¡æœ‰ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå‡å°‘å¤šå¤„ç†å™¨ç³»ç»Ÿçš„å¼€é”€ï¼›åå¤„ï¼šæµªè´¹CPUå‘¨æœŸ

**Priority inversion:** The high-priority process is blocked by the low-priority process 

**How to solve:** all processes, including the one that is accessing the data, inherit the high priority until they are done with the resource. When they finish, their priority values revert back to the original values 



#### 2	ç®¡ç¨‹

æŠŠåˆ†æ•£åœ¨å„è¿›ç¨‹ä¸­çš„ä¸´ç•ŒåŒºé›†ä¸­èµ·æ¥è¿›è¡Œç®¡ç† 

åŒæ—¶åªèƒ½æœ‰**ä¸€ä¸ªè¿›ç¨‹**åœ¨**ä¸€ä¸ªç®¡ç¨‹**å†…æ‰§è¡Œï¼Œè‹¥ä¸€ä¸ªè¿›ç¨‹Pè°ƒç”¨ä¸€ä¸ªç®¡ç¨‹çš„å¤„ç†ç¨‹åºè€Œè¿™ä¸ªç®¡ç¨‹å†…å·²ç»æœ‰å…¶ä»–è¿›ç¨‹Qåœ¨æ‰§è¡Œï¼Œåˆ™På°†è¢«é˜»å¡åœ¨ç®¡ç¨‹å¤–é¢ã€‚

**æ¡ä»¶å˜é‡**â­

To allow a process to **wait within the monitor**, a condition variable must be declared, as condition
x, y;

æ¡ä»¶å˜é‡åªèƒ½ç”¨waitã€signalä½¿ç”¨

- `x.wait()`ï¼šè°ƒç”¨è¯¥åŠŸèƒ½çš„è¿›ç¨‹è¢«æŒ‚èµ·ï¼Œç›´åˆ°å¦å¤–ä¸€ä¸ªè¿›ç¨‹æ‰§è¡Œ`x.signal()`
- `x.signal()`ï¼šæ¢å¤ä¸€ä¸ªç‰¹å®šçš„è¢«æŒ‚èµ·çš„è¿›ç¨‹ï¼Œå¦‚æœæ²¡æœ‰è¿›ç¨‹è¢«æŒ‚èµ·ï¼Œè¿™ä¸ªæ“ä½œæ²¡æœ‰effect

> ç®¡ç¨‹å’Œè¿›ç¨‹çš„åŒºåˆ«ï¼š
>
> - ç®¡ç¨‹å®šä¹‰çš„æ˜¯å…¬ç”¨æ•°æ®ç»“æ„ï¼Œè€Œè¿›ç¨‹å®šä¹‰çš„æ˜¯ç§æœ‰æ•°æ®ç»“æ„
>
>
> - ç®¡ç¨‹æŠŠå…±äº«å˜é‡ä¸Šçš„åŒæ­¥æ“ä½œé›†ä¸­èµ·æ¥ï¼Œè€Œä¸´ç•ŒåŒºå´åˆ†æ•£åœ¨æ¯ä¸ªè¿›ç¨‹ä¸­
>
>
> - ç®¡ç¨‹æ˜¯ä¸ºç®¡ç†å…±äº«èµ„æºè€Œå»ºç«‹çš„ï¼Œè¿›ç¨‹ä¸»è¦æ˜¯ä¸ºå æœ‰ç³»ç»Ÿèµ„æºå’Œå®ç°ç³»ç»Ÿå¹¶å‘æ€§è€Œå¼•å…¥çš„
>
>
> - ç®¡ç¨‹æ˜¯è¢«æ¬²ä½¿ç”¨å…±äº«èµ„æºçš„è¿›ç¨‹æ‰€è°ƒç”¨ï¼Œç®¡ç¨‹å’Œè°ƒç”¨å®ƒçš„è¿›ç¨‹ä¸èƒ½å¹¶å‘å·¥ä½œï¼Œè€Œè¿›ç¨‹ä¹‹é—´èƒ½å¹¶å‘å·¥ä½œ
>
>
> - ç®¡ç¨‹æ˜¯è¯­è¨€æˆ–æ“ä½œç³»ç»Ÿçš„æˆåˆ†ï¼Œä¸å¿…åˆ›å»ºæˆ–æ’¤é”€ï¼Œè€Œè¿›ç¨‹æœ‰ç”Ÿå‘½å‘¨æœŸï¼Œç”±åˆ›å»ºè€Œäº§ç”Ÿè‡³æ’¤é”€ä¾¿æ¶ˆäº¡



### 6.7	ä¸‰å¤§ç»å…¸åŒæ­¥é—®é¢˜çš„è§£å†³æ–¹æ¡ˆ

çœ‹å¯¼å­¦é—®é¢˜ç­”æ¡ˆ



## chp7	Deadlocks

### 7.1	æ­»é”

> å¦‚æœä¸¤ä¸ªæˆ–å¤šä¸ªè¿›ç¨‹æ°¸ä¹…ç­‰å¾…æŸä¸ªäº‹ä»¶ï¼Œè€Œä¸”è¯¥äº‹ä»¶åªèƒ½ç”±è¿™äº›ç­‰å¾…è¿›ç¨‹çš„æŸä¸€ä¸ªå¼•èµ·ï¼Œé‚£ä¹ˆå°±å‡ºç°äº†æ­»é”çŠ¶æ€ã€‚

> å’Œé¥¥é¥¿çš„åŒºåˆ«ï¼š
>
> - é¥¥é¥¿æ˜¯æŒ‡é•¿æœŸå¾—ä¸åˆ°æƒ³è¦çš„èµ„æºï¼Œå¯¼è‡´è¿›ç¨‹æ— æ³•å‘å‰æ¨è¿›çš„ç°è±¡
> - åŒï¼šéƒ½æ˜¯ç”±äºèµ„æºæ— æ³•è·å–ï¼Œå¯¼è‡´è¿›ç¨‹æ— æ³•å‘å‰æ¨è¿›
> - å¼‚ï¼šæ­»é”è¿›ç¨‹æ°¸è¿œå¾—ä¸åˆ°èµ„æºï¼Œé¥¥é¥¿è¿›ç¨‹ç­‰å¾…æ—¶é—´æ²¡æœ‰ä¸Šç•Œï¼›æ­»é”ä¸€å®šæ¶‰åŠå¤šä¸ªè¿›ç¨‹ï¼Œé¥¥é¥¿å¯èƒ½åªæ¶‰åŠä¸€ä¸ªè¿›ç¨‹ï¼›æ­»é”ä¸€å®šå‘ç”Ÿå¾ªç¯ç­‰å¾…ï¼Œé¥¥é¥¿åˆ™ä¸å®šï¼Œ

**æ¦‚å¿µèµ„æºåˆ†é…å›¾**

è¿›ç¨‹æŒ‡å‘èµ„æºæŒ‡çš„æ˜¯è¿›ç¨‹å‘èµ„æºç”³è¯·å®ä¾‹

èµ„æºæŒ‡å‘è¿›ç¨‹æŒ‡çš„æ˜¯è¿›ç¨‹å æœ‰ç€èµ„æºçš„ä¸€ä¸ªå®ä¾‹(is holding an instance)

**ç‰¹å¾ã€æ¡ä»¶**

- äº’æ–¥ï¼šä¸€æ¬¡åªèƒ½æœ‰ä¸€ä¸ªè¿›ç¨‹ä½¿ç”¨æŸèµ„æºï¼ˆå•å®ä¾‹ï¼‰
- å æœ‰å¹¶ç­‰å¾…ï¼šä¸€ä¸ªè¿›ç¨‹å¿…é¡»åœ¨æ‹¥æœ‰æŸèµ„æºçš„æƒ…å†µä¸‹ï¼Œç­‰å¾…å…¶ä»–çš„èµ„æº
- éæŠ¢å ï¼šåªæœ‰æ‹¥æœ‰æŸèµ„æºçš„è¿›ç¨‹èƒ½å¤Ÿè‡ªæ„¿åœ°é‡Šæ”¾ï¼Œé‡Šæ”¾å³è¯´æ˜è¿›ç¨‹å®Œæˆäº†å®ƒçš„å·¥ä½œ
- å¾ªç¯ç­‰å¾…ï¼šAç­‰Bï¼ŒBç­‰Cï¼ŒCç­‰Aï¼ˆåŒ…å«å æœ‰å¹¶ç­‰å¾…ï¼‰



### 7.2	æ­»é”å¤„ç†

1. é‡‡ç”¨æŸç§æ–¹æ³•**é¢„é˜²æˆ–é¿å…**æ­»é”ï¼Œè®©ç³»ç»Ÿæ°¸è¿œä¸ä¼šè¿›å…¥æ­»é”çŠ¶æ€
2. å…è®¸ç³»ç»Ÿè¿›å…¥æ­»é”çŠ¶æ€ï¼Œæ£€æµ‹æ­»é”ï¼ˆæ­»é”å‘ç°ï¼‰ç„¶åæ¢å¤ã€‚
3. å®Œå…¨å¿½ç•¥è¿™ä¸ªé—®é¢˜ï¼Œå‡è®¾ç³»ç»Ÿä»æ¥éƒ½ä¸ä¼šå‡ºç°æ­»é”ã€‚ï¼ˆå¤§å¤šæ•°ç³»ç»Ÿé‡‡ç”¨ï¼‰



### 7.3	æ­»é”é¢„é˜²

**ç ´åå››ä¸ªæ¡ä»¶ä¹‹ä¸€**

1. äº’æ–¥ã€‚å¢åŠ å®ä¾‹ä¸ªæ•°ï¼šå‡ç ´åäº’æ–¥æ¡ä»¶

2. å æœ‰å¹¶ç­‰å¾…ã€‚è§„å®šè¿›ç¨‹ä¸èƒ½åœ¨å æœ‰èµ„æºçš„æ—¶å€™åŒæ—¶ç”³è¯·å…¶ä»–èµ„æº

   å¯è¡Œçš„ç­–ç•¥ï¼š1ï¼‰åœ¨è¿è¡Œå‰è·å–æ‰€æœ‰èµ„æºï¼Œ2ï¼‰ç”³è¯·æ–°èµ„æºå‰é‡Šæ”¾å·²æœ‰èµ„æº

   èµ„æºåˆ©ç”¨ç‡ä½ï¼ˆé•¿æœŸå ç”¨ï¼Œå¯èƒ½ä¸ç”¨ï¼‰ï¼›å¯èƒ½äº§ç”Ÿé¥¥é¥¿ï¼ˆä¸€ä¸ªè¿›ç¨‹è¦æ— é™æœŸç­‰èµ„æºï¼‰

3. éæŠ¢å ã€‚å…è®¸æŠ¢å ï¼Œè‹¥å½“å‰ç”³è¯·çš„èµ„æºä¸å¯ç”¨ï¼Œåˆ™

   1ï¼‰è‹¥èµ„æºçš„å æœ‰è€…ä»éœ€ç­‰å¾…å…¶ä»–çš„èµ„æºï¼Œåˆ™æŠ¢èµ°ä»–~**ï¼ˆæŠ¢åˆ«äººï¼‰**

   2ï¼‰å¦åˆ™ï¼Œå½“å‰ç”³è¯·çš„è¿›ç¨‹åˆ™éœ€ç­‰å¾…ï¼Œåœ¨ç­‰å¾…æœŸé—´ï¼Œå®ƒçš„èµ„æºä¹Ÿæ˜¯å¯æŠ¢å çš„**ï¼ˆè¢«æŠ¢ï¼‰**

4. å¾ªç¯ç­‰å¾…ã€‚ç»™èµ„æºç¼–å·ï¼Œä¸€ä¸ªè¿›ç¨‹åªèƒ½ç”³è¯·æ¯”å…¶å æœ‰èµ„æºç§ç±»æ›´é«˜ï¼ˆåºå·æ›´é«˜ï¼‰çš„èµ„æºã€‚



### 7.4	æ­»é”é¿å…

> OSè·å¾—æ›´å¤šä¿¡æ¯ååˆ¤æ–­ï¼Œå½“å‰è¯·æ±‚æ˜¯å¦å¯ä»¥è¢«å…è®¸ï¼Œæˆ–åº”å½“è¢«æ¨è¿Ÿã€‚

æ­»é”é¿å…ç®—æ³•åŠ¨æ€åˆ†æèµ„æºåˆ†é…çŠ¶æ€ï¼Œç¡®ä¿æ°¸è¿œä¸ä¼šå‡ºç°**ç¯ç­‰**

**å®‰å…¨çŠ¶æ€**

å½“ä¸€ä¸ªè¿›ç¨‹ç”³è¯·èµ„æºæ—¶ï¼Œç³»ç»Ÿè¦åˆ¤æ–­è¯¥æ¬¡åˆ†é…åç³»ç»Ÿæ˜¯å¦å¤„äºå®‰å…¨çŠ¶æ€ï¼Œå³å¯¹æ‰€æœ‰è¿›ç¨‹å‡å­˜åœ¨ä¸€ä¸ªå®‰å…¨åºåˆ—
$$
<P_1,P_2,...,P_n>
$$
ï¼Œå³å¯¹ä»»ä½•ä¸€ä¸ªPi(i>j)ï¼Œå…¶è¦ç”³è¯·çš„èµ„æºå¯ä»¥è¢«å½“å‰ç©ºé—²çš„èµ„æºå’Œæ‰€æœ‰Pjæ‹¥æœ‰çš„èµ„æºæ‰€æ»¡è¶³ã€‚

ã€å¤„äºéå®‰å…¨çŠ¶æ€â€”â€”â€”â€”**å¯èƒ½**æœ‰æ­»é”ï¼›å¤„äºå®‰å…¨çŠ¶æ€ï¼Œä¸€å®šæ²¡æœ‰æ­»é”ã€‘



**èµ„æºåˆ†é…å›¾ç®—æ³•**ï¼ˆå•å®ä¾‹èµ„æºï¼‰

Claim edgeï¼š**è™šçº¿**ç®­å¤´ï¼ŒPæŒ‡å‘Rè¯´æ˜P**å¯èƒ½**ä¼šç”³è¯·èµ„æºR

Request edgeï¼šç”³è¯·äº†åˆ™å˜æˆå®ç°

èµ„æºè¢«é‡Šæ”¾åï¼Œç”³è¯·çº¿åˆå˜æˆè™šçº¿ï¼ˆclaim edgeï¼‰



**é“¶è¡Œå®¶ç®—æ³•**ï¼ˆå¤šå®ä¾‹èµ„æºï¼‰

- Availableï¼Œä¸€ç»´æ•°ç»„ï¼Œä¸åŒèµ„æºå¯ç”¨å®ä¾‹ä¸ªæ•°
- Maxï¼ŒäºŒç»´æ•°ç»„ï¼Œä¸åŒè¿›ç¨‹ä¼šç”³è¯·çš„å„ä¸ªèµ„æºçš„æœ€å¤šå®ä¾‹ä¸ªæ•°
- Allocationï¼ŒäºŒç»´æ•°ç»„ï¼Œå½“å‰åˆ†é…ç»™ä¸åŒè¿›ç¨‹çš„å„ä¸ªèµ„æºçš„å®ä¾‹ä¸ªæ•°
- Needï¼ŒäºŒç»´æ•°ç»„ï¼Œä¸åŒè¿›ç¨‹ä»éœ€çš„å„ä¸ªèµ„æºçš„å®ä¾‹ä¸ªæ•°

æ–°æ¥äº†ä¸€ä¸ªrequestï¼Œæ­¥éª¤ï¼šæ£€æŸ¥æ˜¯å¦å°äºneedï¼Œæ£€æŸ¥æ˜¯å¦å°äºavailableï¼Œå‡è®¾åˆ†é…èµ„æºåè°ƒç”¨å®‰å…¨ç®—æ³•æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸€ä¸ªå®‰å…¨åºåˆ—

**å®‰å…¨ç®—æ³•**

ï¼ˆåœ¨é“¶è¡Œå®¶ç®—æ³•ç¬¬ä¸‰æ­¥å·²ç»å‡è®¾åˆ†é…èµ„æºäº†ï¼ŒAvailableï¼ŒNeedï¼ŒAllocationæ›´æ–°äº†ï¼Œä½†æ²¡ç¡®è®¤æ›´æ–°ï¼‰

- Work=Available
- Finishï¼Œä¸€ç»´æ•°ç»„ï¼Œåˆå€¼ä¸ºfalse

æ­¥éª¤ï¼šæ‰¾åˆ°ä¸€ä¸ªiï¼Œfinish[i]=false, **Need[i]<Work**â­ï¼Œå¹¶æ›´æ–°**Work+=Allocation[i], finish[i]=true**ã€‚ç›´åˆ°æ‰¾ä¸åˆ°iï¼Œæœ€åçœ‹çœ‹finishæ˜¯å¦å…¨ä¸ºtrueï¼Œæ˜¯çš„è¯ç³»ç»Ÿå®‰å…¨ã€‚

å®‰å…¨ï¼šæ‰¾åˆ°çš„içš„é¡ºåºå³ä¸ºå®‰å…¨åºåˆ—çš„é¡ºåº



### 7.5	æ­»é”å‘ç°

**å•èµ„æºå®ä¾‹**

ç»´æŠ¤ä¸€ä¸ªwait-for graphï¼ŒPiæŒ‡å‘Pjå³Piåœ¨ç­‰å¾…Pjï¼Œç»“ç‚¹éƒ½æ˜¯è¿›ç¨‹

å‘¨æœŸæ€§è°ƒç”¨ç®—æ³•ï¼Œ**searches for a cycle** in the graphï¼ŒO(e^2)ï¼Œe=edge_num

**å¤šèµ„æºå®ä¾‹**

- Availableï¼šä¸€ç»´æ•°ç»„ï¼ŒåŒä¸Š
- Allocationï¼šäºŒç»´æ•°ç»„ï¼ŒåŒä¸Š
- Requestï¼šäºŒç»´æ•°ç»„ï¼Œä¸åŒï¼Œå¯¹åº”ç€æŸä¸ªè¿›ç¨‹å¯¹æŸä¸ªèµ„æºçš„å®ä¾‹ç”³è¯·ä¸ªæ•°

æ£€æµ‹ç®—æ³•

- Work=Available
- Finishï¼Œä¸€ç»´æ•°ç»„ï¼Œè‹¥**Allocation[i]=0,åˆ™Finish[i]=true**ï¼Œ**å¦åˆ™ä¸ºfalse**

æ­¥éª¤ï¼šæ‰¾åˆ°ä¸€ä¸ªiï¼ŒFinish[i]=falseä¸”**Request[i]<=Work**â­ï¼Œæ›´æ–°**Work+=Allocation[i], Finish[i]=true**ã€‚ç›´åˆ°æ²¡æœ‰iæ»¡è¶³æ¡ä»¶äº†ï¼Œçœ‹Finishæ•°ç»„ï¼Œè‹¥æœ‰falseï¼Œåˆ™ç³»ç»Ÿå¤„äºæ­»é”æ€ã€‚è¿›ä¸€æ­¥è€Œè¨€ï¼Œè‹¥Finish[i]=falseï¼Œåˆ™Piå¤„äºæ­»é”æ€ã€‚



## chp8	Memory Management

### 8.1	åŸºæœ¬æ¦‚å¿µ

**ä¸»å­˜å’Œå¯„å­˜å™¨**æ˜¯CPUèƒ½ç›´æ¥è®¿é—®çš„å­˜å‚¨ä»‹è´¨ï¼ŒCacheåœ¨ä¸»å­˜å’Œå¯„å­˜å™¨ä¹‹é—´

**åŸºå€å¯„å­˜å™¨å’Œç•Œé™å¯„å­˜å™¨**ç”¨äºå†…å­˜ä¿æŠ¤ï¼Œå®šä¹‰äº†åˆæ³•çš„åœ°å€ç©ºé—´

**é€»è¾‘åœ°å€ç©ºé—´ä¸ç‰©ç†åœ°å€ç©ºé—´**

- é€»è¾‘åœ°å€æ˜¯CPUç”Ÿæˆçš„
- ç‰©ç†åœ°å€æ˜¯å†…å­˜å•ä½æ‰€èƒ½è§çš„
- ä¸¤è€…åœ¨compile-time and load-time address-binding schemesæ˜¯**ç›¸åŒ**çš„ï¼Œä½†åœ¨execution-time address binding schemeæ˜¯**ä¸åŒ**çš„
- ç”¨**é‡å®šä½å¯„å­˜å™¨**æ¥åŠ¨æ€é‡å®šä½â€”â€”Dynamic relocation using a relocation register



### 8.2	è¿ç»­åˆ†é…

*å›ºå®šåˆ†åŒº*



**å¯å˜åˆ†åŒº**

**Holeå­”**ï¼šå¯ç”¨çš„å†…å­˜å—

If the hole is larger than the requested size, it is cut into two. The **one** of the requested size is **given to the process**, the **remaining one** becomes a **new hole**. 

When a process returns a memory block, it **becomes a hole** and **must be combined** with its neighbors ï¼ˆæŒ‡çš„æ˜¯é‚»å±…å­”ï¼Œä¸æ˜¯é‚»å±…è¿›ç¨‹ï¼‰.

**åŠ¨æ€åˆ†é…é—®é¢˜çš„ä¸‰ç§æ–¹æ³•**

1. é¦–æ¬¡é€‚åº”ï¼šåˆ†é…ç»™ç¬¬ä¸€ä¸ªå¤Ÿå¤§çš„å­”
2. æœ€ä½³é€‚åº”ï¼šåˆ†é…ç»™æœ€ä½³å¤§çš„å­”ï¼ˆæœ€å°ä¸”å¤Ÿå¤§ï¼‰
3. æœ€å·®é€‚åº”ï¼šåˆ†é…ç»™æœ€å¤§çš„å­”

é¦–æ¬¡é€‚åº”ã€æœ€ä½³é€‚åº”åœ¨å‡å°‘æ—¶é—´ã€å­˜å‚¨ç©ºé—´åˆ©ç”¨ç‡æ–¹é¢æ¯”æœ€å·®é€‚åº”å¥½ï¼›ä½†å¯¹äºå­˜å‚¨ç©ºé—´åˆ©ç”¨ç‡ï¼ˆstorage utilizationï¼‰è€Œè¨€ï¼Œé¦–æ¬¡é€‚åº”ã€æœ€ä½³é€‚åº”ä¸ä¸€å®šè¯´å“ªä¸ªæ›´å¥½ï¼Œä½†é¦–æ¬¡é€‚åº”ä¸€èˆ¬æ˜¯æ›´å¿«ã€‚



### 8.3	ç¢ç‰‡

==å†…éƒ¨ç¢ç‰‡==æ˜¯å¤„äº**é¡µé¢å†…éƒ¨**çš„å­˜å‚¨å—ï¼Œå æœ‰**è¿™äº›é¡µé¢çš„è¿›ç¨‹**å¹¶**ä¸ä½¿ç”¨**è¿™ä¸ªå­˜å‚¨å—ï¼ŒåŒæ—¶**ç³»ç»Ÿä¹Ÿæ— æ³•åˆ©ç”¨**å®ƒï¼Œç›´åˆ°è¿›ç¨‹é‡Šæ”¾å«æœ‰å†…éƒ¨ç¢ç‰‡çš„é¡µé¢ï¼Œç³»ç»Ÿæ‰æœ‰å¯èƒ½åˆ©ç”¨è¿™ä¸ªå­˜å‚¨å—ã€‚

ï¼ˆä»…ä»…ç»™è¿›ç¨‹å…¶ç”³è¯·çš„ä¸€æ¨¡ä¸€æ ·çš„å†…å­˜ç©ºé—´æ˜¯**ä¸æ˜æ™º**çš„ï¼Œå› ä¸ºæœ‰å†…å­˜ç®¡ç†çš„æœ€å°éœ€æ±‚ï¼‰

==å¤–éƒ¨ç¢ç‰‡==æ˜¯å¤„äº**ä»»ä½•å·²åˆ†é…é¡µé¢å¤–éƒ¨çš„**ç©ºé—²å­˜å‚¨å—ï¼Œå³ä½¿è¿™äº›å­˜å‚¨å—çš„æ€»å’Œå¯ä»¥æ»¡è¶³å½“å‰ç”³è¯·çš„é•¿åº¦è¦æ±‚ï¼Œä½†ç”±äºè¿™äº›å­˜å‚¨å—åœ°å€**ä¸è¿ç»­**ï¼Œä½¿å¾—ç³»ç»Ÿä¹Ÿ**æ— æ³•æ»¡è¶³**å½“å‰ç”³è¯·ã€‚

**æ¶ˆé™¤å¤–éƒ¨ç¢ç‰‡çš„æ–¹æ³•ï¼š**

1. Compactionå‹ç¼©â€”â€”â€”â€”æŠŠæ‰€æœ‰ç©ºé—²çš„å†…å­˜é›†ä¸­èµ·æ¥å˜æˆä¸€ä¸ªå¤§çš„å—ï¼Œæ–¹æ³•å¯è¡Œå½“ä¸”ä»…å½“åˆ†é…çš„åŠ¨æ€çš„ï¼Œè€Œä¸”åœ¨æ‰§è¡Œæ—¶é—´å°±å·²ç»å®Œæˆï¼Œå‹ç¼©æ˜¯é«˜è€—çš„ã€‚ï¼ˆä¸æ˜¯æ°¸è¿œå¯è¡Œï¼‰
2. å…è®¸ä¸€ä¸ªè¿›ç¨‹çš„ç‰©ç†åœ°å€ç©ºé—´æ˜¯ä¸è¿ç»­çš„â€”â€”â€”â€”é‡‡ç”¨åˆ†é¡µå’Œåˆ†å‰²ï¼ˆpaging & segmentationï¼‰æ®µé¡µå¼ï¼Ÿ



### 8.4	åˆ†é¡µ

**é¡µè¡¨**

åŒ…å«ç€æ¯ä¸€ä¸ªé¡µåœ¨ç‰©ç†å†…å­˜ä¸­çš„åŸºå€

Contains **base address** of **each page** in **physical memory**



**é¡µä¸å¸§**

å¸§å¤§å°=é¡µå¤§å°

> Divide **physical memory** into **fixed-sized** **blocks** called ==frames(å¸§/é¡µæ¡†)== 
>
> Divide **logical memory** into blocks of **same size** called ==pages(é¡µ)==

è¿è¡Œä¸€ä¸ªå…·æœ‰**nå¤§å°é¡µ**çš„ç¨‹åºï¼Œéœ€è¦æ‰¾åˆ°**nå¤§å°ç©ºé—²çš„å¸§**ç„¶åè¯»å–ç¨‹åº

ï¼ˆåˆ†é¡µæ˜¯æ¸…é™¤å¤–éƒ¨ç¢ç‰‡çš„æ–¹æ³•ï¼Œä»ç„¶ä¼šæœ‰å†…éƒ¨ç¢ç‰‡ï¼‰



**é¡µå¤§å°çš„å–å€¼å› ç´ **â­

- å†…éƒ¨ç¢ç‰‡â€”â€”â€”â€”å¸Œæœ›å°é¡µ
- table sizeâ€”â€”â€”â€”å¸Œæœ›å¤§é¡µ
- I/O å¼€é”€â€”â€”â€”â€”å¸Œæœ›å¤§é¡µ
- localityâ€”â€”â€”â€”å¸Œæœ›å°é¡µ
- TLB Reachâ€”â€”â€”â€”å¸Œæœ›å¤§é¡µ



**é€»è¾‘åœ°å€ç»“æ„**

**Page number(p):** Index into a page tableï¼ˆé¡µè¡¨çš„é¡¹çš„ç´¢å¼•ï¼‰

**Page offset(d):** Combined with **base address** to **define the physical memory** address that is sent to the memory unitï¼ˆç”±é¡µè¡¨é¡¹æ‰¾åˆ°åŸºå€åï¼ŒåŠ ä¸Šåç§»é‡å¾—åˆ°çœŸæ­£çš„åœ°å€ï¼‰

> ç»™å®šä¸€ä¸ªé€»è¾‘åœ°å€ç©ºé—´2^m^,é¡µå¤§å°2^n^ï¼ˆå¸§å¤§å°ä¹Ÿä¸º2^n^ï¼‰ï¼Œåˆ™
>
> page number	|	page offset
>
> â€‹		m-n			  |			n



> Exerciseï¼šå¦‚æœå¸§çš„å¤§å°ä¸º4KBï¼Œé‚£ä¹ˆå…·æœ‰4Bå¤§å°é¡µè¡¨æ¡ç›®(page table entry)çš„ç³»ç»Ÿå¯ä»¥è®¿é—®çš„æœ€å¤§ç‰©ç†å†…å­˜ç©ºé—´ä¸ºå¤šå°‘ï¼Ÿ
>
> ç­”ï¼š4B=32bitï¼Œä¸€ä¸ªå¸§ï¼ˆé¡µï¼‰å¤§å°ä¸º4KB=2^12^Bï¼Œå¸§ä¸ªæ•°(é¡µä¸ªæ•°) * å¸§å¤§å°(é¡µå¤§å°)=**2^32^ * 2^12^B =2^44^B**
>
> Exercise-Cont. è‹¥å›ºå®šé¡µè¡¨å¤§å°ä¸ºä¸€é¡µå‘¢ï¼Ÿ
>
> ç­”ï¼šé¡µå¤§å°ä¸º1é¡µï¼Œçº¦æŸå’Œç‰©ç†åœ°å€ç©ºé—´å¤§å°æ²¡æœ‰å…³ç³»ï¼Œç­”æ¡ˆè¿˜æ˜¯2^44^Bï¼Œé¡µè¡¨å¤§å°é™åˆ¶çš„æ˜¯é€»è¾‘ç©ºé—´å¤§å°è€Œå·²



**é¡µè¡¨å®ç°ï¼ˆå¯„å­˜å™¨ã€PTBRã€TLBï¼‰**

1. **å¯„å­˜å™¨ï¼šç®€å•ï¼Œé€‚åˆå°é¡µè¡¨**

2. **Page-Table Base Registerï¼ˆPTBRï¼‰**

   é¡µè¡¨ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œä½¿ç”¨PTBRæŒ‡å‘é¡µè¡¨ã€‚åœ¨è¿™ä¸ªæƒ…å†µä¸‹ï¼Œæ¯ä¸ªæ•°æ®/æŒ‡ä»¤çš„è·å–éœ€è¦ä¸¤æ¬¡å†…å­˜è¯»å–(two memory accesses)ï¼Œä¸€æ¬¡æ˜¯æ‰¾é¡µè¡¨ï¼Œä¸€æ¬¡æ˜¯æ‰¾æ•°æ®/æŒ‡ä»¤ã€‚æ•…Memory accessé€Ÿåº¦å‡æ…¢ã€‚

3. **translation look-aside bufferï¼ˆTLBï¼‰**ï¼ˆ*å¿«è¡¨*ï¼‰

   è§£å†³ä¸¤æ¬¡å†…å­˜è¯»å–çš„é—®é¢˜ã€‚

   > Page#     |       Frame#

   å¦‚æœpage#åœ¨TLBä¸­ï¼Œç›´æ¥æŠŠå¯¹åº”çš„Frame#è¯»å–å‡ºæ¥å°±å¥½ï¼Œå¦åˆ™å†ä»å†…å­˜çš„é¡µè¡¨ä¸­è¯»å–å¸§#

   ä¸€äº›TLBåœ¨å…¶å…¥å£å­˜å‚¨**åœ°å€ç©ºé—´æ ‡è¯†ç¬¦ï¼ˆaddress-space identifiersï¼ˆASIDsï¼‰ï¼‰**ï¼Œä»¥ç‹¬ä¸€æ— äºŒåœ°åˆ†è¾¨ä¸åŒçš„è¿›ç¨‹ï¼Œæä¾›å¯¹ç›¸åº”è¿›ç¨‹çš„**åœ°å€ç©ºé—´ä¿æŠ¤**æªæ–½ã€‚ASIDå…è®¸TLBåŒæ—¶åŒ…å«ä¸åŒè¿›ç¨‹çš„å…¥å£ï¼Œä¸ç„¶çš„è¯å®ƒéœ€è¦åœ¨æ¯æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶åˆ·æ–°ã€‚



**Hit Ratioå‘½ä¸­ç‡**

> Percentage of times that a **page number is found in TLB**

$$
hit\ ratio=Î±,\ \ \ \ \ \ TLB \ lookup=Îµ\ time\ unit,\ \ \ \ \ \ memory\ cycle \ time=1ms
$$

$$
Effective\ Access\ Time=(1+Îµ)Î±+(2+Îµ)(1-Î±)=2+Îµ-Î±
$$

**å†…å­˜ä¿æŠ¤**

åœ¨**åˆ†é¡µç¯å¢ƒ**ä¸‹ï¼Œå°†**ä¿æŠ¤ä½**å’Œæ¯ä¸ªå¸§ç›¸äº’å…³è”èµ·æ¥

**Valid-invalid bit** attached to each entry in the page tableï¼š

- Valid: The associated page is in the process's logical address space, and is a legal page
- Invalid: The page is not in the process's logical address space

ä½¿ç”¨**page table length register(PTLR)**ä¿å­˜ä¸€ä¸ªè¿›ç¨‹çš„é¡µè¡¨çš„é•¿åº¦ï¼Œè¿™æ ·çš„è¯ä¸€ä¸ªè¿›ç¨‹å°±ä¸èƒ½è®¿é—®å®ƒèŒƒå›´ä¹‹å¤–çš„å†…å­˜



**é¡µè¡¨ç»“æ„â€”â€”å±‚æ¬¡ç»“æ„**

å°†**é€»è¾‘åœ°å€ç©ºé—´**åˆ†æˆ**å¤šä¸ª**é¡µè¡¨ï¼Œä¾‹å¦‚==ä¸¤å±‚é¡µè¡¨==ï¼š

A **logical address** (on **32-bit** machine with **4K page size**) is divided into: 

- A **page number** consisting of 20 bitsï¼ˆä¸‹é¢å¾—åˆ°äº†offset12ä½ï¼Œæ‰€ä»¥è¿™é‡Œæ˜¯32-12=20ä½ï¼‰
- A **page offset** consisting of 12 bits. ï¼ˆå› ä¸ºé¡µè¡¨å¤§å°ä¸º 4Kï¼Œ4KB=2^12^B=12ä½ï¼‰



Since the page table is **paged**, the **page number** is further divided into: 

- A 10-bit page table number.
- A 10-bit page table offset.

> page number     |    page offset
>
> p1    |     p2			|			d
>
> 10    |      10			|			12

<img src="_review.assets/æ•è·.PNG" alt="æ•è·" style="zoom: 60%;" />

<img src="_review.assets/æ•è·2.PNG" alt="æ•è·2" style="zoom:60%;" />

ï¼ˆå¯¼å­¦é—®é¢˜+15å¹´æœŸè€ƒé¢˜ï¼‰



## chp9	Virtual Memory

### 9.1	æŒ‰éœ€è°ƒé¡µ

Bring a page into memory only when it's needed

Lazy Swapper(Pager)ï¼šNever swaps a page into memory unless page will be needed

Valid-Invalid Bitï¼šä¸æ¯ä¸ªpage table entryå…³è”ï¼Œ1ä»£è¡¨valid && in-memoryï¼Œ0ä»£è¡¨invalid || not-in-memoryï¼Œåˆå§‹å€¼ä¸º0ï¼Œåœ¨åœ°å€è½¬æ¢æ—¶ï¼Œå¦‚æœè¯¥ä½ä¸º0åˆ™å«**page faultï¼ˆç¼ºé¡µï¼‰**

ç¬¬ä¸€æ¬¡å¯¹é¡µçš„æŸ¥æ‰¾ï¼ˆfirst referenceï¼‰ä¸€å®šæ˜¯ç¼ºé¡µï¼ŒOSçœ‹çœ‹å®ƒçš„å†…éƒ¨tableï¼Œæ˜¯invalid referenceå°±ç»ˆæ­¢abortï¼Œå¦‚æœæ˜¯ä»…ä»…ä¸åœ¨å†…å­˜é‡Œï¼Œå°±æ‹¿ä¸€ä¸ªç©ºçš„frameï¼ŒæŠŠpageç½®æ¢åˆ°frameé‡Œï¼Œç„¶åé‡ç½®tablesï¼Œå°†bitå˜ä¸º1ï¼Œç„¶åé‡å¯instruction



**æœ‰æ•ˆè®¿é—®æ—¶é—´**

è®¾pä¸ºç¼ºé¡µç‡
$$
EAT=(1-p)Ã—memory\ access\ time+p(page\ fault\ overhead)
$$

$$
page\ fault\ overhead=serviece\ the\ pagefault\ interrupt+[swap\ page\ out]+swap\ page\ in+restart\ overhead
$$



### 9.2	é¡µç½®æ¢ç®—æ³•

æ²¡æœ‰ç©ºé—²çš„å¸§ï¼Œå°±ä½¿ç”¨é¡µç½®æ¢ç®—æ³•é€‰æ‹©ä¸€ä¸ªå—å®³è€…å¸§ï¼Œå°†å…¶å†™å…¥ç£ç›˜ï¼Œç„¶åä¿®æ”¹é¡µè¡¨ã€å¸§è¡¨ï¼Œç„¶åé‡å¯è¿›ç¨‹

modify(dirty) bitï¼šå‡å°‘é¡µç½®æ¢æ—¶é—´ï¼Œå¤–é¢ç£ç›˜æœ‰å°±ä¸å†™å‡ºå»äº†ï¼Œæ–°æ¥çš„ç›´æ¥è¦†ç›–victimå°±å¥½äº†



#### 1.	FIFO

å…ˆæ¥çš„å…ˆè¿›ï¼Œä¹Ÿå…ˆèµ°

**Belady Anomalyï¼ˆBelady å¼‚å¸¸ï¼‰**â­ï¼ˆç®—æ³•2ã€3**ä¸ä¼šæœ‰**Beladyå¼‚å¸¸ï¼‰

éšç€å¸§æ•°é‡çš„å¢åŠ ï¼Œç¼ºé¡µç‡åè€Œä¹Ÿå¢åŠ äº†



#### 2.	Optimal Algorithm æœ€ä¼˜ç®—æ³•

ç½®æ¢ä¸€ä¸ªæœ€é•¿æ—¶é—´å†…ä¸ä¼šç”¨åˆ°çš„é¡µï¼ˆå°†æ¥çš„ï¼‰

ï¼ˆæ€ä¹ˆçŸ¥é“å‘¢â€¦â€¦æ‰€ä»¥ç”¨æ¥è¡¡é‡è®¾è®¡ç®—æ³•çš„æ•ˆæœï¼‰



#### 3.	Least Recently Used (LRU)

ç½®æ¢ä¸€ä¸ªæœ€é•¿æ—¶é—´æ²¡æœ‰ç”¨çš„é¡µï¼ˆä¹‹å‰çš„ï¼‰

å®ç°æ–¹æ³•ï¼š

1) Counter: Every time page is referenced through this entry, the clock is copied in to the counter. SO, we can replace the page with the **smallest** time value

2) Stack: When a page is referenced, remove it from the stack and put it on the top. **LRU** page is **always at the bottom**



### 9.3	Thrashing	ç³»ç»Ÿé¢ ç°¸

ä¸€ä¸ªè¿›ç¨‹æ²¡æœ‰è¶³å¤Ÿçš„å¸§ï¼Œå®ƒçš„ç¼ºé¡µç‡å¾ˆé«˜ï¼ŒCPUåˆ©ç”¨ç‡å¾ˆä½ï¼Œæ­¤æ—¶OSè®¤ä¸ºè¦å¢åŠ å¤šé“ç¨‹åºåº¦ï¼Œåˆ™å…¶ä»–è¿›ç¨‹ä¼šç»§ç»­è¢«åŠ è½½è¿›æ¥â€¦â€¦

**å«ä¹‰â­**ï¼šA process is busy swapping pages in and out

**åŸå› â­**ï¼šsize of locality > allocated memory size

(A locality is a set of pages that are actively used together)

**è§£å†³â­ï¼ˆ2ç§ï¼Œæœ€å®ç”¨ï¼šç¼ºé¡µç‡çš„ç›‘ç®¡ï¼‰**

1. Working-Set Model

    â–²= working-set windowï¼šæ˜¯ä¸€ä¸ªå›ºå®šçš„é¡µçš„è®¿é—®æ¬¡æ•°(a fixed number of page references)

   WSS~i~(working-set of process P~i~) = total number of pages referenced in the most recent â–²

   -  â–²å¤ªå°ä¸èƒ½åŒ…å«æ•´ä¸ªlocality
   -  â–²å¤ªå¤§ä¼šåŒ…å«å¤šä¸ªlocality
   -  â–²æ— ç©·ä¼šåŒ…å«æ•´ä¸ªç¨‹åº

   The working set is an approximation of the programâ€™s locality. 

   D = Î£WWS~i~=total demand frames

   è‹¥D>m â†’ é¢ ç°¸ â†’ suspend one of the processes

2. Page-Fault Frequencyç›‘ç®¡ï¼Œè®¾å®šä¸€ä¸ªå¯ä»¥æ¥å—çš„ç¼ºé¡µç‡

   è‹¥å®é™…ç¼ºé¡µç‡å¤ªé«˜ï¼Œè¿›ç¨‹è·å¾—æ–°çš„å¸§ï¼›å¦åˆ™ï¼Œä¸¢å¤±å¸§



## chp10	File System Interface

### 10.1	æ–‡ä»¶çš„æ¦‚å¿µ

A file is a **named collection** of **related information** that is recorded on **secondary storage**.

ï¼ˆæœ‰**è¿ç»­**çš„**é€»è¾‘**åœ°å€â­ï¼‰



### 10.2	è®¿é—®æ–¹æ³•ï¼ˆé¡ºåºï¼Œç›´æ¥ï¼‰

**é¡ºåºè®¿é—®**

**ç›´æ¥è®¿é—®**



## chp11	File System Implementation

### 11.1	æ–‡ä»¶åˆ†é…ï¼ˆè¿ç»­ã€é“¾æ¥ã€ç´¢å¼•ï¼‰

æ–‡ä»¶åˆ†é…çš„æ–¹æ³•å³ï¼šç£ç›˜å—æ˜¯å¦‚ä½•åˆ†é…ç»™æ–‡ä»¶ä½¿ç”¨çš„

#### 1	Contiguous Allocation	è¿ç»­åˆ†é…

æ¯ä¸ªæ–‡ä»¶å æœ‰ä¸€ç»„è¿ç»­çš„ç£ç›˜å—

- ç®€å•ï¼šåªéœ€è¦starting locationã€length(number of blocks)

- éšæœºè®¿é—®ï¼šä½¿ç”¨é¡ºåºã€ç›´æ¥è®¿é—®ï¼›

- æµªè´¹ç©ºé—´ï¼Œä¸”æ–‡ä»¶ä¸èƒ½å˜å¤§ï¼ˆåœ¨Extent-based systemä¸­ï¼Œæ”¯æŒæ–‡ä»¶çš„æ‰©å……ï¼‰



#### 2	Linked Allocation	é“¾æ¥åˆ†é…

æ¯ä¸€ä¸ªæ–‡ä»¶éƒ½æ˜¯ç£ç›˜å—çš„é“¾è¡¨ï¼Œå—çš„ä½ç½®æ˜¯ä»»æ„çš„

- ç®€å•ï¼šåªéœ€è¦starting addressã€end address

- ä¸ä¼šæœ‰å¤–éƒ¨ç¢ç‰‡

- æ–‡ä»¶å¯ä»¥å˜å¤§

- ä¸èƒ½éšæœºè®¿é—®

- æµªè´¹ç©ºé—´ï¼šæ¯ä¸€å—éƒ½æœ‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€å—



#### 3	Indexed allocation	ç´¢å¼•åˆ†é…

å°†æ‰€æœ‰çš„æŒ‡é’ˆé›†åˆèµ·æ¥ï¼Œæ”¾åœ¨ç´¢å¼•å—(index block)ä¸­

ï¼ˆå°±æ˜¯directoryä¸­å­˜çš„æ–‡ä»¶åå¯¹åº”çš„æ˜¯ä»–çš„index blockä¸‹æ ‡ï¼Œç„¶åå®ƒçš„index blocké‡Œé¢å­˜çš„æ˜¯å­˜æ”¾è¿™ä¸ªæ–‡ä»¶æ‰€ç”¨çš„æ‰€æœ‰å—çš„æŒ‡é’ˆï¼ˆåœ°å€ï¼‰ï¼‰

- å¯ä»¥éšæœºè®¿é—®
- æµªè´¹ç©ºé—´ï¼Œä¾‹å¦‚index blockä¸æ˜¯å®Œå…¨è¢«ä½¿ç”¨ï¼Œæœ‰å†…éƒ¨ç¢ç‰‡
- æ–‡ä»¶å¤§å°å–å†³äºindex tableçš„entryæ•°



çŸ¥é“ç´¢å¼•åæ¨å¯¼å‡ºæ¥æ”¯æŒçš„æœ€å¤§å¤§å°ï¼Ÿ



### 11.2	ç©ºé—²ç©ºé—´ç®¡ç†ï¼ˆä½å‘é‡ã€é“¾è¡¨ï¼‰

å¦‚ä½•è®°å½•ç©ºé—²å—ï¼Ÿ

A **free-space list** is maintained. When a new block is  requested, we search this list to find one.



#### 1	Bit vector	ä½å‘é‡

å¯¹n blocksè€Œè¨€ï¼Œä½å‘é‡`bit`çš„`bit[i]=1`è¯´æ˜`block[i]`æ˜¯ç©ºé—²çš„ï¼Œ`bit[i]=0`è¯´æ˜`block[i]`è¢«å ç”¨äº†

**Block number calculation**

(number of bits per word) Ã— (number of 0-value words) + offset of first 1 bit



#### 2	Linked List	é“¾è¡¨

ç”¨ä¸€ä¸ªfree-space list headæŒ‡é’ˆæŒ‡å‘æœ€å¼€å§‹çš„ç©ºé—²å—ï¼Œç„¶åå„ä¸ªç©ºé—²å—ç›´æ¥ä¾æ¬¡ä»¥æŒ‡é’ˆç›¸è¿å½¢æˆé“¾è¡¨

- Cannot get contiguous space easily
- No waste of space



*3	Linked List + Grouping*

*4	Linked List + Address + Count*



## chp12	Mass Storage Structure

### 12.1	*ç£ç›˜ç»“æ„*ï¼ˆä¼ è¾“é€Ÿç‡ã€å®šä½æ—¶é—´ï¼‰

**ä¼ è¾“é€Ÿç‡ï¼ˆTransfer rateï¼‰**ç¡¬ç›˜å’Œç”µè„‘ä¹‹é—´æ•°æ®æµçš„ä¼ è¾“é€Ÿç‡ï¼ˆæ¯ç§’å…†å­—èŠ‚ï¼‰

**å®šä½æ—¶é—´ï¼ˆPositioning time/ Random-access timeï¼‰**

Time to **move disk arm to desired cylinder** (**seek time**) and (plus) time for **desired sector to rotate under the disk head** (**rotational latency**)

Mappingé¡ºåºï¼šä»ä¸Šåˆ°ä¸‹ï¼Œä»å¤–æŸ±é¢åˆ°é‡ŒæŸ±é¢ï¼ˆè·è½¬è½´çš„åŒä¸€è·ç¦»çš„æ‰€æœ‰sectoréƒ½å­˜æ»¡äº†ï¼ˆä¸åŒå±‚ï¼‰ï¼Œæ¢å¤´æ‰å¾€é‡Œé¢ä¼¸ï¼‰



### 12.2	ç£ç›˜è°ƒåº¦ç®—æ³•

**å¯»é“æ—¶é—´â­(Seek time)**

Time for the disk are to move the heads to the cylinder containing the desired sector

**æ—‹è½¬å»¶æ—¶(Rotational latency)**

Additional time waiting for the disk to rotate the desired sector to the disk head

Access time = Seek time + Rotational latency

**ç£ç›˜å¸¦å®½â­(Disk bandwidth)**

The total number of bytes transferred, divided by the total time between the first request for service and the completion of the last transfer
$$
\frac{Total\ number\ of\ bytes\ transferred}{total\ time\ between\ the\ first\ request\ for\ service\ and\ the\ completion\ of\ the\ last\ transfer}
$$
**å¯»é“è·ç¦»â­(Seek distance)**

å¯»é“è¿‡ç¨‹ä¸­ï¼Œdisk headèµ°è¿‡çš„è·ç¦»

å¯»é“è·ç¦»çš„è®¡ç®—æ–¹æ³•ï¼šå¯¹æ¯ä¸ªæ–¹å‘ï¼Œæœ€å¤§å€¼â€”æœ€å°å€¼ï¼Œç„¶åæŠŠæ‰€æœ‰ç»“æœåŠ èµ·æ¥



ï¼ˆä»¥ä¸‹ç®—æ³•å»ºè®®é…åˆpptå›¾é£Ÿç”¨ï¼‰

#### 1.	FCFS

first come first served



#### 2.	SSTF

Shortest seek time first

å¯¹disk headæ‰€åœ¨ä½ç½®è€Œè¨€ï¼Œä¸‹ä¸€ä¸ªå¯»æ‰¾çš„ä½ç½®æ€»æ˜¯ç¦»å½“å‰ä½ç½®æœ€è¿‘çš„

å¯èƒ½ä¼šäº§ç”Ÿ**é¥¥é¥¿**



#### 3.	SCANâ€”â€”ç”µæ¢¯ç®—æ³•

åœ¨è¯»å–ä¸‹ä¸€ä¸ªå‰ï¼Œçœ‹çœ‹å½“å‰disk headç§»åŠ¨çš„æ–¹å‘ï¼ŒæŒ‰ç…§è¿™ä¸ªæ–¹å‘ç§»åŠ¨åˆ°å¤´ï¼ˆå°¾ï¼‰è¯»å–ï¼Œå†åå‘è¯»å–è‡³å°¾ï¼ˆå¤´ï¼‰ã€‚æ³¨æ„ï¼šç§»åŠ¨åˆ°æœ€åä¸€ä¸ªä½ç½®ï¼ˆqueueä¸­çš„éƒ½è¯»è¿‡äº†ï¼‰å°±åœè½¦



#### 4.	C-SCAN

Câ€”â€”æœ‰ç©ºè·‘

åœ¨è¯»å–ä¸‹ä¸€ä¸ªå‰ï¼Œçœ‹çœ‹å½“å‰disk headç§»åŠ¨çš„æ–¹å‘ï¼ŒæŒ‰ç…§è¿™ä¸ªæ–¹å‘ç§»åŠ¨åˆ°å¤´ï¼ˆå°¾ï¼‰è¯»å–ã€‚ç„¶åç©ºè½¦è¿”å›åˆ°å°¾ï¼ˆå¤´ï¼‰ï¼ŒæŒ‰åŸæ–¹å‘ç»§ç»­è¯»å–ã€‚æ³¨æ„ï¼šç§»åŠ¨åˆ°æœ€åä¸€ä¸ªä½ç½®ï¼ˆqueueä¸­çš„éƒ½è¯»è¿‡äº†ï¼‰å°±åœè½¦

Provides a more uniform wait time than SCAN



#### 5.	LOOK

åœ¨è¯»å–ä¸‹ä¸€ä¸ªå‰ï¼Œçœ‹çœ‹å½“å‰disk headç§»åŠ¨çš„æ–¹å‘ï¼ŒæŒ‰ç…§è¿™ä¸ªæ–¹å‘ç§»åŠ¨åˆ°queueä¸­çš„æœ€å¤§ï¼ˆæœ€å°ï¼‰ä½ç½®å°±å¥½äº†ã€‚ç„¶ååå‘è¯»åˆ°æœ€å°ï¼ˆæœ€å¤§ï¼‰ä½ç½®ã€‚



#### 6.	C-LOOK

Câ€”â€”æœ‰ç©ºè·‘ï¼Œç©ºè½¦è¿”å›åˆ°ç”³è¯·çš„æœ€å¤§/æœ€å°ä½ç½®ï¼ŒæŒ‰åŸæ–¹å‘â€¦â€¦



### 12.3	ç£ç›˜è°ƒåº¦ç®—æ³•é€‰æ‹©

- **SSTF** is common and has a natural appeal
- **SCAN and C-SCAN** perform better for systems that place a **heavy load** on the disk
- Either **SSTF or LOOK** is a reasonable choice for the default algorithm
- Performance depends on the number and types of requests
- Requests for disk service can be influenced by the file-allocation method
- The location of directories and index blocks is also important



### 12.4	ç£ç›˜ç®¡ç†ï¼ˆæ ¼å¼åŒ–ã€å¼•å¯¼å—ã€ç¯å—ï¼‰

**ä½å±‚çš„æ ¼å¼åŒ–/ç‰©ç†æ ¼å¼åŒ–**â€”â€”å°†ç£ç›˜åˆ†æˆå‡ ä¸ªåŒºåŸŸï¼Œä½¿å¾—ç£ç›˜æ§åˆ¶å™¨å¯ä»¥è¿›è¡Œè¯»å†™æ“ä½œ

**å¼•å¯¼å—	Boot block**

å¼•å¯¼å—ç”¨æ¥åˆå§‹åŒ–ç³»ç»Ÿï¼Œå­˜æ”¾åœ¨ROMä¸­ï¼ŒBootstrap loader program

**ç¯å—**

A disk track with a bad sector. 

1. ç”¨ä¸€ä¸ªç©ºé—²çš„å—æ›¿ä»£é‚£ä¸ªbad sector
2. æˆ–è€…ï¼Œç»•è¿‡é‚£ä¸ªbad sectorï¼Œshift all sectorsï¼ˆé‡æ–°ç¼–å·ã€ç§»åŠ¨ï¼‰



## chp13	 IO Systems

### 13.1	I/Oç¡¬ä»¶ï¼ˆè½®è¯¢ã€ä¸­æ–­ã€DMAï¼‰

åŒ…å«ï¼šè®¾å¤‡ã€æ€»çº¿ã€æ§åˆ¶å™¨â€¦â€¦

I/O portä¸€èˆ¬ç”±å››ä¸ªå¯„å­˜å™¨ç»„æˆ

- data-in register: read by the host to get input
- data-out register: ........ send output
- status register: Can be read by the host
- control register: Can be written by the host to start a command or to change the mode of a device

ä¸»æœºå’Œæ§åˆ¶å™¨ä¹‹é—´çš„äº¤äº’ï¼š

**1ï¼‰Polling	è½®è¯¢**

The **controller** indicates its state through the busy bit in the status register.

The **host** signals its wishes via the command-ready bit in the control register.

The host is busy-waiting or polling



**2ï¼‰Interrupts	ä¸­æ–­**

æ•ˆç‡ä½ï¼Œäº§ç”Ÿä¸€ä¸ªä¸­æ–­å°±å¤„ç†

The **device controller** raises an **interrupt** by asserting a signal on the interrupt request line, the **CPU** catches the interrupt and **dispatches** it to the **interrupt handler**, and the handler **clears the interrupt** by **servicing the device**.



**3ï¼‰DMA**

æ•ˆç‡é«˜ï¼Œä¸€å¼€å§‹CPUå°±æŠŠéœ€è¦å¤„ç†çš„disk addressã€memory addressã€byte countç»™æ§åˆ¶å™¨ï¼Œå°±å›å»ç»§ç»­åšå®ƒçš„ä»»åŠ¡äº†



### 13.2	å†…æ ¸I/Oç³»ç»Ÿï¼ˆç¼“å†²ã€ç¼“å­˜ã€å‡è„±æœºï¼‰

**1ï¼‰Buffering	ç¼“å†²**ï¼š

**A memory area that stores data** being transferred between two devices or between a device and an
application.

Coping with a **speed mismatch** between the producer and consumer of a data stream

Providing **adaptations** for devices that have **different data-transfer sizes**

Supporting **copy semantics** for application I/O

(å¯èƒ½æ•°æ®ä¼šè¢«ä¿®æ”¹ï¼Œæ‰€ä»¥ä¿è¯å†™å‡ºå»çš„æ˜¯æƒ³è¦çš„)



**2ï¼‰Caching	ç¼“å­˜**ï¼šè§£å†³è®¿é—®æ•ˆç‡é—®é¢˜

A region of **fast memory** that holds **copies** of data

ï¼ˆç¼“å†²å’Œç¼“å†²çš„åŠŸèƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼‰



**3ï¼‰Spooling	å‡è„±æœº**ï¼šè§£å†³å¹¶å‘è®¿é—®çš„é—®é¢˜ï¼ˆæ‰“å°æœºï¼‰

**A buffer that holds output for a device** that cannot accept interleaved data streams.

**ï¼ˆç”¨äºä¿å­˜ä¸èƒ½æ¥å—äº¤é”™æ•°æ®æµçš„è®¾å¤‡çš„è¾“å‡ºçš„ç¼“å†²åŒºï¼‰**



Each applicationâ€™s output is spooled to a separate disk file.

The spooling system copies the queued spool files to the printer one at a time.

Spooling is one way operating systems can coordinate concurrent output.