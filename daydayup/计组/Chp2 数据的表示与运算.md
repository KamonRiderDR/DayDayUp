[TOC]

# Chp 2 数据的表示与运算

## 数制与转换

|              | **二进制** | **八进制**  | **十进制**  | **十六进制**             |
| ------------ | ---------- | ----------- | ----------- | ------------------------ |
| **数码**     | **0,1**    | **0,1,…,7** | **0,1,…,9** | **0,1,…,9,** **A,B,…,F** |
| **基数**     | **2**      | **8**       | **10**      | **16**                   |
| **书写形式** | **B**      | **O**       | **D**       | **H**                    |





## 机器数与编码

> 物质决定意识。

首先需要明确的是，我们不论使用什么样的编码方式，最终的目的都是为了计算，换句话说，就是一个整数加法群的同态映射。

---

显然，数据的组成为：`【符号】+数值`。在计算时，我们的符号与数值分开计算。



### 原码

最简单的编码方式：<font color = red>最高位（**正负**）+剩余（**绝对值**）</font>。我们假设有n位，那最终实际能表达的数就要***减半***。

自然而然地，我们需要对整数和小数分别定义。但核心思想是统一的：即只变换最高位。

- **整数**：<font color = blue>$X=\pm x_{n-2}\ldots x_0 \Rightarrow [X]_{原} = x_{n-1}\cdot x_{n-2} \ldots x_0$</font>


$$
[X]_{原} = 
\begin{cases}
X,X \in [1,2^{n-1}]
\\
2^{n-1}-X = 2^{n-1}+|X| ,X \in [-2^{n-1},0]
\end{cases}
$$
（绝对值是从0开始减的，因为这样不会改变本身的值。）



- **小数**：<font color = blue>$X=\pm 0.x_{-1}\ldots x_{-(n-1)} \Rightarrow [X]_{原} =x_0. x_{-1}\cdots x_{n-1}$</font>

$$
[X]_{原} = 
\begin{cases}
X,X \in [0,1)
\\
1-X = 1+|X| ,X \in (-1,0]
\end{cases}
$$



原码的特性：

①X与[X]原关系—[X]原与X表示值的范围相同，[+0]原≠[-0]原 ← 2n个码表示2n-1个数。

 ②运算方法—符号与数值**分开运算**、减法先比较大小
                                   └→不利于硬件实现←┘



### 补码

> **符号与数值一起运算，减法无需比较大小。**

本质就是模运算。**正数的补码是其本身，负数的补码是它的正补数。**如此，我们可以直接将减法运算转变为加法运算。（简化硬件）
$$
[X]_{补} = 
\begin{cases}
X,X \in [0,2^{n-1}]
\\
2^n+X = 2^n-X = (2^n-1-X)+1 , X \in [-2^{n-1},0)
\end{cases}
$$
对于负数，我们的后（n-2）位其实是<font color = red><b>各位取反+1</b></font>。我们可以这样理解：<font color = darkgreen size = 2>$ 2^{n}-1$其实是各位都是1的求和，此时作差就是取反。</font>

小数的补码如下：
$$
[X]_{补} = 
\begin{cases}
X,X \in [0,1)
\\
2-|X|, X \in [-1,0)
\end{cases}
$$
对于负数，也就是取反加一，个位置1。

> 关于原码和补码之间的相互转换：**都是用加法，没有-1的操作！**

**反码**：作为补码的过渡编码，取反后不需要+1。



<center><font size = 4 color = red><b><I>COMPARISON</I></b></font></center>

①机器数的最高位均为符号位(0/1表示正/负)

②X为正数时，[X]原=[X]补=[X]反
③X为负数时，[X]原符号位=[X]补符号位=[X]反符号位
                    [X]补数值位=[X]原数值位＋1
                    [X]反数值位=[X]原数值位

**④补码比原码、反码多表示一个负数**！（自己演算！）



### 补：移码

**WHY？**比较更方便（原码和补码不好直接比较大小）

**HOW？**<font color = blue>$[X]_移 = 2^{N-1}+X$</font>。这样，所有的数都处在相同的区间内（**+**）



### CONCLUSION

- 原码直观
- 补码对机器友好（反码是过渡码）
- 移码只适用于整数，方便比较大小





## 字符串编码

### 十进制编码 && BCD码

